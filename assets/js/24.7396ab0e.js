(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{518:function(a,t){a.exports="data:image/png;base64,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"},561:function(a,t,s){"use strict";s.r(t);var e=s(3),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("h3",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),e("h4",{attrs:{id:"今天是冬至-大家记得吃饺子哈。本篇文章主要是重塑javascript的第九篇-本篇内容是javascript文法相关的学习。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#今天是冬至-大家记得吃饺子哈。本篇文章主要是重塑javascript的第九篇-本篇内容是javascript文法相关的学习。"}},[a._v("#")]),a._v(" 今天是冬至,大家记得吃饺子哈。本篇文章主要是重塑JavaScript的第九篇，本篇内容是JavaScript文法相关的学习。")]),a._v(" "),e("h4",{attrs:{id:"javascript的运行时内容-基本上告一段落-在之前的知识架构上-开始文法相关内容学习。文法实际上是编译原理对语言写法的一种规定-文法分为词法和语法-而语义与语法是一一对应关系。接下来的内容从词法到语法-但主要还是学习javascript的一些语法。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript的运行时内容-基本上告一段落-在之前的知识架构上-开始文法相关内容学习。文法实际上是编译原理对语言写法的一种规定-文法分为词法和语法-而语义与语法是一一对应关系。接下来的内容从词法到语法-但主要还是学习javascript的一些语法。"}},[a._v("#")]),a._v(" JavaScript的运行时内容，基本上告一段落，在之前的知识架构上，开始文法相关内容学习。文法实际上是编译原理对语言写法的一种规定，文法分为词法和语法，而语义与语法是一一对应关系。接下来的内容从词法到语法，但主要还是学习JavaScript的一些语法。")])]),e("h2",{attrs:{id:"词法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#词法"}},[a._v("#")]),a._v(" 词法")]),a._v(" "),e("h4",{attrs:{id:"之前有学习过关于编译原理相关的一些知识-我们知道javascript是一门高度封装了的编程语言-相当于机器语言-它更加适合人类编写和阅读-但是要想机器知道这段代码要做什么-那么就需要额外的处理了。就比如自然语言的-主谓宾-结构-成语的词组等等-需要给编程语言也加一些规则-机器才能也读懂。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#之前有学习过关于编译原理相关的一些知识-我们知道javascript是一门高度封装了的编程语言-相当于机器语言-它更加适合人类编写和阅读-但是要想机器知道这段代码要做什么-那么就需要额外的处理了。就比如自然语言的-主谓宾-结构-成语的词组等等-需要给编程语言也加一些规则-机器才能也读懂。"}},[a._v("#")]),a._v(" 之前有学习过关于编译原理相关的一些知识，我们知道JavaScript是一门高度封装了的编程语言，相当于机器语言，它更加适合人类编写和阅读，但是要想机器知道这段代码要做什么，那么就需要额外的处理了。就比如自然语言的“主谓宾”结构，成语的词组等等，需要给编程语言也加一些规则，机器才能也读懂。")]),a._v(" "),e("h4",{attrs:{id:"词法对应的词法分析-实际上就是分词-一段代码只是一段字符-通过分词-来定义从那个字母到哪个字母是一个词汇-这个词汇对应的是什么类型。就比如说"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#词法对应的词法分析-实际上就是分词-一段代码只是一段字符-通过分词-来定义从那个字母到哪个字母是一个词汇-这个词汇对应的是什么类型。就比如说"}},[a._v("#")]),a._v(" 词法对应的词法分析，实际上就是分词，一段代码只是一段字符，通过分词，来定义从那个字母到哪个字母是一个词汇，这个词汇对应的是什么类型。就比如说：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = 66\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("h4",{attrs:{id:"那么我们就可以分别识别出var标识符-a标识符-符号-66数字直接量。也就是识别代码的最小单元-通常称作token-然后收集起来形成一个序列。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#那么我们就可以分别识别出var标识符-a标识符-符号-66数字直接量。也就是识别代码的最小单元-通常称作token-然后收集起来形成一个序列。"}},[a._v("#")]),a._v(" 那么我们就可以分别识别出var标识符，a标识符，=符号，66数字直接量。也就是识别代码的最小单元，通常称作token，然后收集起来形成一个序列。")]),a._v(" "),e("h4",{attrs:{id:"这种识别的机制可以通过正则文法和有限状态机来实现-这里大概说一下-实际上就是以正则规则的形式-进行确认-比如标识符也就是我们的变量名-它是以-、-或者字母开头-那么就检测第一个字符是否为这个类型-然后进行每个字符的规则检测-看看是否符合标识符规则-而如果恰巧三个字符对应了var-那么就可以定义为声明关键字。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这种识别的机制可以通过正则文法和有限状态机来实现-这里大概说一下-实际上就是以正则规则的形式-进行确认-比如标识符也就是我们的变量名-它是以-、-或者字母开头-那么就检测第一个字符是否为这个类型-然后进行每个字符的规则检测-看看是否符合标识符规则-而如果恰巧三个字符对应了var-那么就可以定义为声明关键字。"}},[a._v("#")]),a._v(" 这种识别的机制可以通过正则文法和有限状态机来实现，这里大概说一下，实际上就是以正则规则的形式，进行确认，比如标识符也就是我们的变量名，它是以$、_或者字母开头，那么就检测第一个字符是否为这个类型，然后进行每个字符的规则检测，看看是否符合标识符规则，而如果恰巧三个字符对应了var 那么就可以定义为声明关键字。")]),a._v(" "),e("h2",{attrs:{id:"javascript词法分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript词法分类"}},[a._v("#")]),a._v(" JavaScript词法分类")]),a._v(" "),e("h4",{attrs:{id:"接下来我们看一下javascript词法的定义-javascript源代码中的输入可以这样分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接下来我们看一下javascript词法的定义-javascript源代码中的输入可以这样分类"}},[a._v("#")]),a._v(" 接下来我们看一下JavaScript词法的定义，Javascript源代码中的输入可以这样分类：")]),a._v(" "),e("ul",[e("li",[a._v("WhiteSpace空白字符")]),a._v(" "),e("li",[a._v("LineTerminator 换行符")]),a._v(" "),e("li",[a._v("Comment 注释")]),a._v(" "),e("li",[a._v("Token 词\n1.IdentifierName标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。\n2.Punctuator符号，我们使用的运算符和大括号等符号。"),e("br"),a._v("\n3.NumericLiteral数字直接量，就是我们写的数字。"),e("br"),a._v("\n4.StringLiteral字符串直接量，就是我们用单引号或者双引号引起来的直接量。"),e("br"),a._v("\n5.Template字符串模板，用反引号`括起来的直接量")])]),a._v(" "),e("h4",{attrs:{id:"按照这个分类对应我们的解析方式-词法分析中往往会出现一些单靠自己规则没法处理的场景-就比如说-除法符号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按照这个分类对应我们的解析方式-词法分析中往往会出现一些单靠自己规则没法处理的场景-就比如说-除法符号"}},[a._v("#")]),a._v(" 按照这个分类对应我们的解析方式，词法分析中往往会出现一些单靠自己规则没法处理的场景，就比如说/除法符号")]),a._v(" "),e("p",[a._v("、/=除等于符号、/abc/正则表达式，它们都以/开头，并且后续能加入的字符规则也有耦合，所以JavaScript的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。好吧，这些东西都为我们处理好了，但是实际上还有一些影响比较不常见。")]),a._v(" "),e("h2",{attrs:{id:"词法规则造成的影响"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#词法规则造成的影响"}},[a._v("#")]),a._v(" 词法规则造成的影响")]),a._v(" "),e("h4",{attrs:{id:"我们有时会用到一把数字转换成字符串的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我们有时会用到一把数字转换成字符串的方式"}},[a._v("#")]),a._v(" 我们有时会用到一把数字转换成字符串的方式：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" var num = 100;\n num.toString(); // '100'\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("h4",{attrs:{id:"按照前面类型篇时讲过-这里num变量是一个基本数字类型-在调用方法时使用了包装对象转换成了临时对象-因此有tostring可以使用。如果我们直接拿一个基本类型调用方法呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按照前面类型篇时讲过-这里num变量是一个基本数字类型-在调用方法时使用了包装对象转换成了临时对象-因此有tostring可以使用。如果我们直接拿一个基本类型调用方法呢"}},[a._v("#")]),a._v(" 按照前面类型篇时讲过，这里num变量是一个基本数字类型，在调用方法时使用了包装对象转换成了临时对象，因此有toString可以使用。如果我们直接拿一个基本类型调用方法呢？")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("'100'.toString();  // '100'\ntrue.toString(); // 'true'\n100.toString(); // Uncaught SyntaxError: Invalid or unexpected token\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("h4",{attrs:{id:"用字符串和boolean这样写没问题-但是数字却报错了-难道针对数字做了啥奇奇怪怪的我们不知道的事情-实际上这里只是因为在扫描到1这个字符之后-便进入了数字字面量的定义-100扫描完成后继续下一个字符扫描-一个-作为数字字面量中的一部分并没有什么问题-小数嘛-那么顺其自然的-就把100-作为了一个token-继续查找发现-后面是一个字母-不符合规则。因此导致了这个词法错误。实际上我们稍微处理一下就没问题了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用字符串和boolean这样写没问题-但是数字却报错了-难道针对数字做了啥奇奇怪怪的我们不知道的事情-实际上这里只是因为在扫描到1这个字符之后-便进入了数字字面量的定义-100扫描完成后继续下一个字符扫描-一个-作为数字字面量中的一部分并没有什么问题-小数嘛-那么顺其自然的-就把100-作为了一个token-继续查找发现-后面是一个字母-不符合规则。因此导致了这个词法错误。实际上我们稍微处理一下就没问题了"}},[a._v("#")]),a._v(" 用字符串和Boolean这样写没问题，但是数字却报错了，难道针对数字做了啥奇奇怪怪的我们不知道的事情？实际上这里只是因为在扫描到1这个字符之后，便进入了数字字面量的定义，100扫描完成后继续下一个字符扫描，一个.作为数字字面量中的一部分并没有什么问题，小数嘛，那么顺其自然的，就把100.作为了一个token，继续查找发现.后面是一个字母，不符合规则。因此导致了这个词法错误。实际上我们稍微处理一下就没问题了：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("100 .toString(); // '100'\n100..toString(); // '100'\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("h4",{attrs:{id:"按照规则-保证词法分析对100单独列为一个词-那么就不会有这个问题了。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按照规则-保证词法分析对100单独列为一个词-那么就不会有这个问题了。"}},[a._v("#")]),a._v(" 按照规则，保证词法分析对100单独列为一个词，那么就不会有这个问题了。")]),a._v(" "),e("h4",{attrs:{id:"关于词法的内容-就介绍这些了-相对而言-其中原理还是很好理解的。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于词法的内容-就介绍这些了-相对而言-其中原理还是很好理解的。"}},[a._v("#")]),a._v(" 关于词法的内容，就介绍这些了，相对而言，其中原理还是很好理解的。")]),a._v(" "),e("h2",{attrs:{id:"语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[a._v("#")]),a._v(" 语法")]),a._v(" "),e("h4",{attrs:{id:"语法的处理相对于词法就要抽象很多了-就好比从自然语言的词汇学习上升到句子学习-语法解析是在拿到词法解析的token序列后-通过定义好的语法产生式-构建一个-抽象语法树-语法产生式的写法有很多-下面是巴科斯范式写的加法和乘法表达式的语法产生式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法的处理相对于词法就要抽象很多了-就好比从自然语言的词汇学习上升到句子学习-语法解析是在拿到词法解析的token序列后-通过定义好的语法产生式-构建一个-抽象语法树-语法产生式的写法有很多-下面是巴科斯范式写的加法和乘法表达式的语法产生式"}},[a._v("#")]),a._v(' 语法的处理相对于词法就要抽象很多了，就好比从自然语言的词汇学习上升到句子学习，语法解析是在拿到词法解析的token序列后，通过定义好的语法产生式，构建一个"抽象语法树"，语法产生式的写法有很多，下面是巴科斯范式写的加法和乘法表达式的语法产生式：')]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("additiveExpression\n    ::=   multiplicativeExpression\n    |   multiplicativeExpression Plus additiveExpression\n    ;\n\nmultiplicativeExpression\n    ::=   number\n    |   number Star multiplicativeExpression\n    ;\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br")])]),e("h4",{attrs:{id:"这里简单说一下这个东西怎么玩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这里简单说一下这个东西怎么玩"}},[a._v("#")]),a._v(" 这里简单说一下这个东西怎么玩，")]),a._v(" "),e("h4",{attrs:{id:"上面的两个产生式-定义了一些规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#上面的两个产生式-定义了一些规则"}},[a._v("#")]),a._v(" 上面的两个产生式，定义了一些规则：")]),a._v(" "),e("p",[a._v("1.加法表达式，必须由一个乘法表达式，或者一个惩罚表达式，一个Plus(也就是+号)以及一个加法表达式组成。"),e("br"),a._v("\n2.乘法表达式，必须由一个数字字面量，或者一个数字字面量，一个Star(也就是*号)以及一个乘法表达式组成。")]),a._v(" "),e("h4",{attrs:{id:"这个规则解读起来和自然语言的主谓宾划分就很像了-通过这样的规则定义-我们通过遍历token序列-就能构造一个树状结构-例如代码2-3-5-就可以获取到这样一个ast"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这个规则解读起来和自然语言的主谓宾划分就很像了-通过这样的规则定义-我们通过遍历token序列-就能构造一个树状结构-例如代码2-3-5-就可以获取到这样一个ast"}},[a._v("#")]),a._v(" 这个规则解读起来和自然语言的主谓宾划分就很像了，通过这样的规则定义，我们通过遍历token序列，就能构造一个树状结构，例如代码2 + 3 * 5，就可以获取到这样一个AST：")]),a._v(" "),e("p",[e("img",{attrs:{src:s(518),alt:"cal-ast-test"}})]),a._v(" "),e("h4",{attrs:{id:"然后-我们就可以通过这个树状的数据结构-进行解释执行-拿到对应的结果了。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#然后-我们就可以通过这个树状的数据结构-进行解释执行-拿到对应的结果了。"}},[a._v("#")]),a._v(" 然后，我们就可以通过这个树状的数据结构，进行解释执行，拿到对应的结果了。")]),a._v(" "),e("h2",{attrs:{id:"语法规则造成的影响"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法规则造成的影响"}},[a._v("#")]),a._v(" 语法规则造成的影响")]),a._v(" "),e("h4",{attrs:{id:"这些问题-引擎都帮我们处理的好好的-可同样对于编写代码者-它的处理机制会造成一定的影响。例如我们常常会遇到的一个问题-代码中是否需要写分号-。我们先看一个不加分号带来问题的场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这些问题-引擎都帮我们处理的好好的-可同样对于编写代码者-它的处理机制会造成一定的影响。例如我们常常会遇到的一个问题-代码中是否需要写分号-。我们先看一个不加分号带来问题的场景"}},[a._v("#")]),a._v(" 这些问题，引擎都帮我们处理的好好的，可同样对于编写代码者，它的处理机制会造成一定的影响。例如我们常常会遇到的一个问题，代码中是否需要写分号(😉。我们先看一个不加分号带来问题的场景：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("(function fn1() {\n  console.log('fn1')\n})()\n(function fn2() {\n  console.log('fn2')\n})()\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("h4",{attrs:{id:"上面代码会输出fn1-然后报错-intermediate-value-is-not-a-function-这里的原因是什么呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#上面代码会输出fn1-然后报错-intermediate-value-is-not-a-function-这里的原因是什么呢"}},[a._v("#")]),a._v(" 上面代码会输出fn1，然后报错(intermediate value)(...) is not a function，这里的原因是什么呢？")]),a._v(" "),e("h4",{attrs:{id:"我们的目的是想写两个函数自调用-但是实际上第一个确实是函数自调用-继而第二个函数自调用-也是以-开头-在推导这段代码的时候-会认为第一个自调用可能会返回一个函数-然后再次调用-而fn2是传递进去的参数。但是实际上返回值并不是想象中的函数-因此报错了。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我们的目的是想写两个函数自调用-但是实际上第一个确实是函数自调用-继而第二个函数自调用-也是以-开头-在推导这段代码的时候-会认为第一个自调用可能会返回一个函数-然后再次调用-而fn2是传递进去的参数。但是实际上返回值并不是想象中的函数-因此报错了。"}},[a._v("#")]),a._v(" 我们的目的是想写两个函数自调用，但是实际上第一个确实是函数自调用，继而第二个函数自调用，也是以(开头，在推导这段代码的时候，会认为第一个自调用可能会返回一个函数，然后再次调用，而fn2是传递进去的参数。但是实际上返回值并不是想象中的函数，因此报错了。")]),a._v(" "),e("h4",{attrs:{id:"类似的因为不加分号会造成这种误会的场景有"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类似的因为不加分号会造成这种误会的场景有"}},[a._v("#")]),a._v(" 类似的因为不加分号会造成这种误会的场景有：")]),a._v(" "),e("p",[a._v("1.以括号开头；"),e("br"),a._v("\n2.以方括号开头；"),e("br"),a._v("\n3.正则开头的斜杠；"),e("br"),a._v("\n4.加号开头；"),e("br"),a._v("\n5.减号开头；"),e("br"),a._v("\n6.以template模板字符串开头。")]),a._v(" "),e("h4",{attrs:{id:"因此我们在处理这些场景的时候可以在对应符号最前面加上-即可。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#因此我们在处理这些场景的时候可以在对应符号最前面加上-即可。"}},[a._v("#")]),a._v(" 因此我们在处理这些场景的时候可以在对应符号最前面加上；即可。")]),a._v(" "),e("h2",{attrs:{id:"javascript语法结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript语法结构"}},[a._v("#")]),a._v(" JavaScript语法结构")]),a._v(" "),e("h4",{attrs:{id:"上面的语法分析是细节上对语句的推导了-我们站在整体上看一下javascript的语法结构。通常我们一个js文件-可以是一个脚本文件也可以是一个模块文件。-我们的划分方式-从引入上是"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#上面的语法分析是细节上对语句的推导了-我们站在整体上看一下javascript的语法结构。通常我们一个js文件-可以是一个脚本文件也可以是一个模块文件。-我们的划分方式-从引入上是"}},[a._v("#")]),a._v(" 上面的语法分析是细节上对语句的推导了，我们站在整体上看一下JavaScript的语法结构。通常我们一个JS文件，可以是一个脚本文件也可以是一个模块文件。   我们的划分方式，从引入上是：")]),a._v(" "),e("ul",[e("li",[a._v("脚本文件是由游览器或者是node环境引入执行；")]),a._v(" "),e("li",[a._v("模块是由JavaScript代码用import引入执行。\n从概念上来讲是：\n"),e("ul",[e("li",[a._v("脚本文件是具有主动性的JavaScript代码段，用来控制宿主完成一些任务的代码；")]),a._v(" "),e("li",[a._v("模块是被动性的JavaScript代码段，等待被调用的工具库。")])])])]),a._v(" "),e("h4",{attrs:{id:"而实际上从语法角度来讲-脚本和模块的区别仅仅是是否包含import和export。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#而实际上从语法角度来讲-脚本和模块的区别仅仅是是否包含import和export。"}},[a._v("#")]),a._v(" 而实际上从语法角度来讲，脚本和模块的区别仅仅是是否包含import和export。")]),a._v(" "),e("h4",{attrs:{id:"我们可以利用script来验证这一点-在游览器环境下-我们可以使用script来加载一个js文件。如"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我们可以利用script来验证这一点-在游览器环境下-我们可以使用script来加载一个js文件。如"}},[a._v("#")]),a._v(" 我们可以利用script来验证这一点，在游览器环境下，我们可以使用script来加载一个JS文件。如：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("<script src='x.js'><\/script>\n\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("h4",{attrs:{id:"这样的引入方式-实际上是游览器默认语言是javascript-所以把type-application-javascript-隐藏了。按照es6的新特性module-我们可以在js中使用import和export来导入和导出模块-如果引入的x-js中导入了一个属性-那么就会产生一个报错unexpected-token-export-。而我们可是解决的方式是指定script的type为module"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这样的引入方式-实际上是游览器默认语言是javascript-所以把type-application-javascript-隐藏了。按照es6的新特性module-我们可以在js中使用import和export来导入和导出模块-如果引入的x-js中导入了一个属性-那么就会产生一个报错unexpected-token-export-。而我们可是解决的方式是指定script的type为module"}},[a._v("#")]),a._v(" 这样的引入方式，实际上是游览器默认语言是JavaScript，所以把type=\"application/javascript\"隐藏了。按照ES6的新特性Module，我们可以在JS中使用import和export来导入和导出模块，如果引入的x.js中导入了一个属性，那么就会产生一个报错Unexpected token 'export'。而我们可是解决的方式是指定script的type为module：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("<script type=\"module\" src='x.js'><\/script>\n\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("h4",{attrs:{id:"而我们在javascript文件可以写很多的语句-因此-我们可以针对脚本模块的划分为"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#而我们在javascript文件可以写很多的语句-因此-我们可以针对脚本模块的划分为"}},[a._v("#")]),a._v(" 而我们在JavaScript文件可以写很多的语句，因此，我们可以针对脚本模块的划分为：")]),a._v(" "),e("p",[e("img",{attrs:{src:"module-script-difference.png",alt:"module-script-difference"}})]),a._v(" "),e("h4",{attrs:{id:"对于type为module和export与import的使用特点-就不在这里多说啦。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对于type为module和export与import的使用特点-就不在这里多说啦。"}},[a._v("#")]),a._v(" 对于type为module和export与import的使用特点，就不在这里多说啦。")]),a._v(" "),e("h4",{attrs:{id:"javascript引擎除了执行脚本和模块之外-还可以执行函数。而函数体跟脚本和模块有一定的相似之处。同样是执行代码段-同样是创建任务在调用栈中执行-执行函数的过程实际上就是在执行函数体也就是花括号中的语句列表。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript引擎除了执行脚本和模块之外-还可以执行函数。而函数体跟脚本和模块有一定的相似之处。同样是执行代码段-同样是创建任务在调用栈中执行-执行函数的过程实际上就是在执行函数体也就是花括号中的语句列表。"}},[a._v("#")]),a._v(" JavaScript引擎除了执行脚本和模块之外，还可以执行函数。而函数体跟脚本和模块有一定的相似之处。同样是执行代码段，同样是创建任务在调用栈中执行，执行函数的过程实际上就是在执行函数体也就是花括号中的语句列表。")]),a._v(" "),e("h4",{attrs:{id:"函数体里面的结构不同也可以进行划分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数体里面的结构不同也可以进行划分"}},[a._v("#")]),a._v(" 函数体里面的结构不同也可以进行划分：")]),a._v(" "),e("p",[a._v("1.普通函数体")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function foo() {\n  // Function body\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("p",[a._v("2.异步函数体")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("async function foo() {\n  // Function body\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("p",[a._v("3.生成器函数体")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function* foo() {\n  // Function body\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("p",[a._v("4.异步生成器函数体")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("async function* foo() { \n  // Function body\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("h4",{attrs:{id:"而这四种函数体的区别在于是否可以在其中使用yield和await语句-关于脚本-模块和函数体-整理一个区别表格"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#而这四种函数体的区别在于是否可以在其中使用yield和await语句-关于脚本-模块和函数体-整理一个区别表格"}},[a._v("#")]),a._v(" 而这四种函数体的区别在于是否可以在其中使用yield和await语句，关于脚本，模块和函数体，整理一个区别表格：")]),a._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[a._v("类型")]),a._v(" "),e("th",{staticStyle:{"text-align":"center"}},[a._v("yield")]),a._v(" "),e("th",{staticStyle:{"text-align":"center"}},[a._v("await")]),a._v(" "),e("th",{staticStyle:{"text-align":"center"}},[a._v("return")]),a._v(" "),e("th",{staticStyle:{"text-align":"center"}},[a._v("import&export")])])]),a._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[a._v("普通函数体")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("√")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")])]),a._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[a._v("异步函数体")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("√")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("√")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")])]),a._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[a._v("生成器函数体")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("√")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("√")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")])]),a._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[a._v("异步生成器函数体")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("√")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("√")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("√")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")])]),a._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[a._v("脚本")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")])]),a._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[a._v("模块")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("x")]),a._v(" "),e("td",{staticStyle:{"text-align":"center"}},[a._v("√")])])])]),a._v(" "),e("h4",{attrs:{id:"这是三种语法结构的区别-接下来看一下javascript语法的全局机制。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这是三种语法结构的区别-接下来看一下javascript语法的全局机制。"}},[a._v("#")]),a._v(" 这是三种语法结构的区别，接下来看一下JavaScript语法的全局机制。")]),a._v(" "),e("h2",{attrs:{id:"预处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#预处理"}},[a._v("#")]),a._v(" 预处理")]),a._v(" "),e("h4",{attrs:{id:"预处理的概念要是结合之前讲过的执行上下文去理解-将会体会的更深入。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#预处理的概念要是结合之前讲过的执行上下文去理解-将会体会的更深入。"}},[a._v("#")]),a._v(" 预处理的概念要是结合之前讲过的执行上下文去理解，将会体会的更深入。")]),a._v(" "),e("h4",{attrs:{id:"预处理就是javascript执行前-会扫描脚本、模块、函数体中的内容-提前处理var-函数声明-class-const-let这些语句。下面分别说一下每一个语句的处理是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#预处理就是javascript执行前-会扫描脚本、模块、函数体中的内容-提前处理var-函数声明-class-const-let这些语句。下面分别说一下每一个语句的处理是什么"}},[a._v("#")]),a._v(" 预处理就是JavaScript执行前，会扫描脚本、模块、函数体中的内容，提前处理var，函数声明，class， const，let这些语句。下面分别说一下每一个语句的处理是什么")]),a._v(" "),e("h3",{attrs:{id:"var"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#var"}},[a._v("#")]),a._v(" var")]),a._v(" "),e("h4",{attrs:{id:"var声明永远作用域脚本、模块和函数体这三个级别-在预处理阶段-不关心赋值的那部分-只管在当前作用域声明这个变量。结合执行上下文篇的内容-在创建执行上下文的时候-会把var声明的变量放入到变量对象中去-并且初始化为undefined-也就是说-在执行的时候-我们就可以提前访问到这个变量-但是值为undefined。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#var声明永远作用域脚本、模块和函数体这三个级别-在预处理阶段-不关心赋值的那部分-只管在当前作用域声明这个变量。结合执行上下文篇的内容-在创建执行上下文的时候-会把var声明的变量放入到变量对象中去-并且初始化为undefined-也就是说-在执行的时候-我们就可以提前访问到这个变量-但是值为undefined。"}},[a._v("#")]),a._v(" var声明永远作用域脚本、模块和函数体这三个级别，在预处理阶段，不关心赋值的那部分，只管在当前作用域声明这个变量。结合执行上下文篇的内容，在创建执行上下文的时候，会把var声明的变量放入到变量对象中去，并且初始化为undefined，也就是说，在执行的时候，我们就可以提前访问到这个变量，但是值为undefined。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log('global start', a);\n// global start undefined\nvar a = 1;\n\nfunction foo() {\n    console.log('function start', a);\n    // function start undefined\n    var a = 2;\n    console.log('function end', a);\n    // function end 2\n}\n\nfoo();\nconsole.log('global end', a);\n// global end 1\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br")])]),e("h4",{attrs:{id:"看这个示例可以发现-在全局上下文中-加入了一个变量a-函数执行时创建函数上下文也加入了一个变量a-都可以提前访问到一个值undefined。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#看这个示例可以发现-在全局上下文中-加入了一个变量a-函数执行时创建函数上下文也加入了一个变量a-都可以提前访问到一个值undefined。"}},[a._v("#")]),a._v(" 看这个示例可以发现，在全局上下文中，加入了一个变量a，函数执行时创建函数上下文也加入了一个变量a，都可以提前访问到一个值undefined。")]),a._v(" "),e("h4",{attrs:{id:"需要注意的是前面也说过了var只认脚本、模块和函数体这三个级别-对于if、for是会穿透的。还有一个特殊的with"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#需要注意的是前面也说过了var只认脚本、模块和函数体这三个级别-对于if、for是会穿透的。还有一个特殊的with"}},[a._v("#")]),a._v(" 需要注意的是前面也说过了var只认脚本、模块和函数体这三个级别，对于if、for是会穿透的。还有一个特殊的with")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = 1;\n\nfunction foo() {\n  var o= {a: 3}\n\ta = 1;\n  with(o) {\n    var a = 2;\n    console.log(a); // 2\n  }\n  console.log(o.a); // 2\n  console.log(a); // 1\n}\n\nfoo();\nconsole.log(a); // 1\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br")])]),e("h4",{attrs:{id:"由于with的创建了一个作用域-导致在with语句中的var确实也被提升到了foo函数中-但是在执行的时候-修改的确实作用域对象o中的属性。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#由于with的创建了一个作用域-导致在with语句中的var确实也被提升到了foo函数中-但是在执行的时候-修改的确实作用域对象o中的属性。"}},[a._v("#")]),a._v(" 由于with的创建了一个作用域，导致在with语句中的var确实也被提升到了foo函数中，但是在执行的时候，修改的确实作用域对象o中的属性。")]),a._v(" "),e("h3",{attrs:{id:"function声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#function声明"}},[a._v("#")]),a._v(" function声明")]),a._v(" "),e("h4",{attrs:{id:"函数声明-它和var相似-也是在创建上下文的时候-将其提前-放入到了词法环境的环境记录中-但是不同的是-它会初始化并且完成赋值。所以我们可以在代码上的函数声明之前调用这个函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数声明-它和var相似-也是在创建上下文的时候-将其提前-放入到了词法环境的环境记录中-但是不同的是-它会初始化并且完成赋值。所以我们可以在代码上的函数声明之前调用这个函数"}},[a._v("#")]),a._v(" 函数声明，它和var相似，也是在创建上下文的时候，将其提前，放入到了词法环境的环境记录中，但是不同的是，它会初始化并且完成赋值。所以我们可以在代码上的函数声明之前调用这个函数：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("fn(); // 'fn'\nfunction fn() {\n  console.log('fn');\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br")])]),e("h4",{attrs:{id:"对于函数声明-需要注意两点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对于函数声明-需要注意两点"}},[a._v("#")]),a._v(" 对于函数声明，需要注意两点：")]),a._v(" "),e("p",[a._v("1.如果这个声明是在if、foo这种没有作用域块的代码结构中，它会产生变量初始化为undefined，但是不会赋值。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log('foo', foo);\nif(true) {\n  function foo(){}\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br")])]),e("p",[a._v("2.它和var的关系，var在扫描到要加入上下文中时，会去查看是否已经有这个属性，如果有，就不再处理。而function声明在发现已经有这样的一个声明的时候，会进行赋值，把原来的值给覆盖掉。因此，会出现var和function声明同一个变量名的时候，访问的都是function。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(a); // ƒ a() {}\nfunction a() {}\nvar a = 1;\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("h3",{attrs:{id:"class、let、const"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#class、let、const"}},[a._v("#")]),a._v(" class、let、const")]),a._v(" "),e("h4",{attrs:{id:"这里把这三个放在一起因为它们的特点是一致的-它们都会在创建上下文的时候加入到其中-但是并不会初始化-因此再提前访问这三种声明的时候都会报错cannot-access-x-before-initialization"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这里把这三个放在一起因为它们的特点是一致的-它们都会在创建上下文的时候加入到其中-但是并不会初始化-因此再提前访问这三种声明的时候都会报错cannot-access-x-before-initialization"}},[a._v("#")]),a._v(" 这里把这三个放在一起因为它们的特点是一致的，它们都会在创建上下文的时候加入到其中，但是并不会初始化，因此再提前访问这三种声明的时候都会报错Cannot access 'x' before initialization")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(c);\nclass c{}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("h4",{attrs:{id:"并且它们不会穿透if、for等语句"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并且它们不会穿透if、for等语句"}},[a._v("#")]),a._v(" 并且它们不会穿透if、for等语句")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(v); // Uncaught ReferenceError: v is not defined\nif (true) {\n  let v = 1;\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br")])]),e("h3",{attrs:{id:"指令序言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#指令序言"}},[a._v("#")]),a._v(" 指令序言")]),a._v(" "),e("h4",{attrs:{id:"脚本和模块都支持一种特殊的语法-叫做指令序言-directive-prologs-。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#脚本和模块都支持一种特殊的语法-叫做指令序言-directive-prologs-。"}},[a._v("#")]),a._v(" 脚本和模块都支持一种特殊的语法，叫做指令序言(Directive Prologs)。")]),a._v(" "),e("h4",{attrs:{id:"这里的指令序言最早是为了use-strict设计的-它规定了一种给javascript代码添加元信息的方式。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这里的指令序言最早是为了use-strict设计的-它规定了一种给javascript代码添加元信息的方式。"}},[a._v("#")]),a._v(" 这里的指令序言最早是为了use strict设计的，它规定了一种给JavaScript代码添加元信息的方式。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('"use strict";\nfunction f(){\n  console.log(this); // null\n};\nf.call(null);\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br")])]),e("h4",{attrs:{id:"在这里使用里-use-strict-使后面的代码都使用严格模式-最终会输出null-javascript的指令序言是只有一个字符串直接量的表达式语句-并且只能出现在脚本、模块和函数体的最前面。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在这里使用里-use-strict-使后面的代码都使用严格模式-最终会输出null-javascript的指令序言是只有一个字符串直接量的表达式语句-并且只能出现在脚本、模块和函数体的最前面。"}},[a._v("#")]),a._v(' 在这里使用里"use strict"使后面的代码都使用严格模式，最终会输出null，JavaScript的指令序言是只有一个字符串直接量的表达式语句，并且只能出现在脚本、模块和函数体的最前面。')]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var a = 1;\n"use strict";\nfunction f(){\n  console.log(this); // Window\n};\nf.call(null);\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),e("h4",{attrs:{id:"本篇文章针对javas学习的文法部分做了拆分学习-了解词法以及语法的处理规则-这两点的内容实则是理解编译原理对语法写法的规定-以及带来的影响。很多时候为什么会有一些不符合我们直接思维的处理。后面对于语法结构以及基本的语法规则做了些总结。结合之前的运行时执行上下文内容可以有更深刻的体会。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#本篇文章针对javas学习的文法部分做了拆分学习-了解词法以及语法的处理规则-这两点的内容实则是理解编译原理对语法写法的规定-以及带来的影响。很多时候为什么会有一些不符合我们直接思维的处理。后面对于语法结构以及基本的语法规则做了些总结。结合之前的运行时执行上下文内容可以有更深刻的体会。"}},[a._v("#")]),a._v(" 本篇文章针对JavaS学习的文法部分做了拆分学习，了解词法以及语法的处理规则，这两点的内容实则是理解编译原理对语法写法的规定，以及带来的影响。很多时候为什么会有一些不符合我们直接思维的处理。后面对于语法结构以及基本的语法规则做了些总结。结合之前的运行时执行上下文内容可以有更深刻的体会。")])])}),[],!1,null,null,null);t.default=r.exports}}]);