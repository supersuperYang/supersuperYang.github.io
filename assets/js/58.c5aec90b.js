(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{592:function(a,t,s){"use strict";s.r(t);var e=s(3),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),s("h4",{attrs:{id:"本篇文章主要是对常见前端面试题做一些整理-整理顺序由-html-css-javascript-vue。-网络层-webpack-node-js还未整理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#本篇文章主要是对常见前端面试题做一些整理-整理顺序由-html-css-javascript-vue。-网络层-webpack-node-js还未整理"}},[a._v("#")]),a._v(" 本篇文章主要是对常见前端面试题做一些整理，整理顺序由 HTML - CSS - Javascript - Vue。 （网络层 - webpack - node.js还未整理）")])]),s("h2",{attrs:{id:"html"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html"}},[a._v("#")]),a._v(" HTML")]),a._v(" "),s("h3",{attrs:{id:"_1-什么是html"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是html"}},[a._v("#")]),a._v(" 1.什么是HTML？")]),a._v(" "),s("h4",{attrs:{id:"html-全称hypertext-markup-language-翻译过来就是超文本标记语言的意思。-不是编程语言-。标记语言是一套标记标签-html用标记标签来描述网页。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html-全称hypertext-markup-language-翻译过来就是超文本标记语言的意思。-不是编程语言-。标记语言是一套标记标签-html用标记标签来描述网页。"}},[a._v("#")]),a._v(" HTML，全称Hypertext Markup Language，翻译过来就是超文本标记语言的意思。(不是编程语言)。标记语言是一套标记标签，HTML用标记标签来描述网页。")]),a._v(" "),s("h3",{attrs:{id:"_2-什么是超链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么是超链接"}},[a._v("#")]),a._v(" 2.什么是超链接？")]),a._v(" "),s("h4",{attrs:{id:"超链接其实就是一段超文本-它集成了其他站点链接的文档。当我们点击这个超链接时-会跳转到另一个页面。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#超链接其实就是一段超文本-它集成了其他站点链接的文档。当我们点击这个超链接时-会跳转到另一个页面。"}},[a._v("#")]),a._v(" 超链接其实就是一段超文本，它集成了其他站点链接的文档。当我们点击这个超链接时，会跳转到另一个页面。")]),a._v(" "),s("h3",{attrs:{id:"_3-为什么html不是编程语言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么html不是编程语言"}},[a._v("#")]),a._v(" 3.为什么HTML不是编程语言？")]),a._v(" "),s("h4",{attrs:{id:"编程语言指的是通过编写指令操作机器来行为-html并不包含任何操作机器行为的-语义。它只是一种电子文档的技术。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编程语言指的是通过编写指令操作机器来行为-html并不包含任何操作机器行为的-语义。它只是一种电子文档的技术。"}},[a._v("#")]),a._v(" 编程语言指的是通过编写指令操作机器来行为，HTML并不包含任何操作机器行为的 语义。它只是一种电子文档的技术。")]),a._v(" "),s("h3",{attrs:{id:"_4-html主要标签分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-html主要标签分类"}},[a._v("#")]),a._v(" 4.HTML主要标签分类")]),a._v(" "),s("p",[a._v("1.文档元信息： 在head标签中的元素，包含了描述文档自身的一些信息；"),s("br"),a._v("\n2.语义相关： 扩展了纯文本，表达文章结构、不同语言要素的标签；"),s("br"),a._v("\n3.链接：提供到文档内和文档外的链接；"),s("br"),a._v("\n4.替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签；"),s("br"),a._v("\n5.表单：用于填写和提交信息的一类标签；"),s("br"),a._v("\n6.表格：表头、表尾、单元格等表格的结构。")]),a._v(" "),s("h3",{attrs:{id:"_5-image标签上title属性和alt属性的区别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-image标签上title属性和alt属性的区别是什么"}},[a._v("#")]),a._v(" 5.image标签上title属性和alt属性的区别是什么？")]),a._v(" "),s("h4",{attrs:{id:"alt属性是游览者看不到文档中的图像时-给用户提供文字说明的。且长度必须小于100个英文字符-如果是中文要保证尽可能的短。-而title属性为设置该属性的元素提供建议性的信息。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#alt属性是游览者看不到文档中的图像时-给用户提供文字说明的。且长度必须小于100个英文字符-如果是中文要保证尽可能的短。-而title属性为设置该属性的元素提供建议性的信息。"}},[a._v("#")]),a._v(" alt属性是游览者看不到文档中的图像时，给用户提供文字说明的。且长度必须小于100个英文字符，如果是中文要保证尽可能的短。 而title属性为设置该属性的元素提供建议性的信息。")]),a._v(" "),s("h3",{attrs:{id:"_6-讲出-文字加粗、下标、居中、字体-的html标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-讲出-文字加粗、下标、居中、字体-的html标签"}},[a._v("#")]),a._v(" 6.讲出 文字加粗、下标、居中、字体 的HTML标签")]),a._v(" "),s("h3",{attrs:{id:"_7-讲讲标签语义化的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-讲讲标签语义化的理解"}},[a._v("#")]),a._v(" 7.讲讲标签语义化的理解？")]),a._v(" "),s("p",[a._v("1.去掉或者丢失样式的时候能够让页面呈现出清晰的结构；"),s("br"),a._v("\n2.有利于SEO，和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息；爬虫依赖于标签来确定上下文和各个关键字的权重；"),s("br"),a._v("\n3.方便其他设备解析(如屏幕阅读器、盲人阅读器、移动设备)以意义的方式来渲染网页；"),s("br"),a._v("\n4.便于团队开发和维护，语义化更具可读性。遵循W3C标准的团队都遵循这个标准，可以减少差异化。")]),a._v(" "),s("h3",{attrs:{id:"_8-doctype作用-严格模式与混杂模式如何区分-它们有何意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-doctype作用-严格模式与混杂模式如何区分-它们有何意义"}},[a._v("#")]),a._v(" 8.Doctype作用？ 严格模式与混杂模式如何区分？ 它们有何意义？")]),a._v(" "),s("h4",{attrs:{id:"doctype声明位于html文档中的第一行-处于html标签之前。告知游览器的解析器用什么文档标准解析这个文档。doctype不存在或格式不正确会导致文档以兼容模式呈现。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#doctype声明位于html文档中的第一行-处于html标签之前。告知游览器的解析器用什么文档标准解析这个文档。doctype不存在或格式不正确会导致文档以兼容模式呈现。"}},[a._v("#")]),a._v(" !DOCTYPE声明位于HTML文档中的第一行，处于html标签之前。告知游览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。")]),a._v(" "),s("h4",{attrs:{id:"标准模式-也称严格模式-的排版和js运作模式都是以该游览器支持的最高标准运行。-在兼容模式-混杂模式或怪异模式-中-页面以宽松向后兼容的方式显示-模拟老式游览器的行为以防止站点无法工作。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标准模式-也称严格模式-的排版和js运作模式都是以该游览器支持的最高标准运行。-在兼容模式-混杂模式或怪异模式-中-页面以宽松向后兼容的方式显示-模拟老式游览器的行为以防止站点无法工作。"}},[a._v("#")]),a._v(" 标准模式(也称严格模式)的排版和JS运作模式都是以该游览器支持的最高标准运行。   在兼容模式(混杂模式或怪异模式)中，页面以宽松向后兼容的方式显示，模拟老式游览器的行为以防止站点无法工作。")]),a._v(" "),s("h4",{attrs:{id:"随着标准一致性越来越越重要-游览器开发商不得不面临一个艰难的抉择-逐渐遵循w3c的标准是前进的方向。但是改变现有的css完全去遵循标准-会使许多就网站或多或少的受到破坏-如果游览器突然以正确的方式解析现存的css-陈旧的网站的显示必然会受到影响。所以-所有的游览器都需要提供两种模式-混杂模式服务旧世规则-严格模式服务于标准规则。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#随着标准一致性越来越越重要-游览器开发商不得不面临一个艰难的抉择-逐渐遵循w3c的标准是前进的方向。但是改变现有的css完全去遵循标准-会使许多就网站或多或少的受到破坏-如果游览器突然以正确的方式解析现存的css-陈旧的网站的显示必然会受到影响。所以-所有的游览器都需要提供两种模式-混杂模式服务旧世规则-严格模式服务于标准规则。"}},[a._v("#")]),a._v(" 随着标准一致性越来越越重要，游览器开发商不得不面临一个艰难的抉择：逐渐遵循W3C的标准是前进的方向。但是改变现有的css完全去遵循标准，会使许多就网站或多或少的受到破坏，如果游览器突然以正确的方式解析现存的css，陈旧的网站的显示必然会受到影响。所以，所有的游览器都需要提供两种模式，混杂模式服务旧世规则，严格模式服务于标准规则。")]),a._v(" "),s("h3",{attrs:{id:"_9-讲讲src与href的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-讲讲src与href的区别"}},[a._v("#")]),a._v(" 9.讲讲src与href的区别")]),a._v(" "),s("h4",{attrs:{id:"href是指向网络资源所在位置-建立和当前元素-锚点-或当前文档-链接-之间的连接-用于超链接。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#href是指向网络资源所在位置-建立和当前元素-锚点-或当前文档-链接-之间的连接-用于超链接。"}},[a._v("#")]),a._v(" href是指向网络资源所在位置，建立和当前元素(锚点)或当前文档(链接)之间的连接，用于超链接。")]),a._v(" "),s("h4",{attrs:{id:"src是指向外部资源的位置-指向的内容会嵌入到文档中当前标签所在位置-在请求src资源时会将其指向的资源下载并引用到文档内-例如js脚本-img图片和frame等元素。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#src是指向外部资源的位置-指向的内容会嵌入到文档中当前标签所在位置-在请求src资源时会将其指向的资源下载并引用到文档内-例如js脚本-img图片和frame等元素。"}},[a._v("#")]),a._v(" src是指向外部资源的位置，指向的内容会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并引用到文档内，例如js脚本，img图片和frame等元素。")]),a._v(" "),s("h4",{attrs:{id:"当游览器解析到该元素时-会暂停其他资源的下载和处理-直到将该资源加载、编译、执行完毕-图片和框架等元素也如此-类似与将所有指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当游览器解析到该元素时-会暂停其他资源的下载和处理-直到将该资源加载、编译、执行完毕-图片和框架等元素也如此-类似与将所有指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。"}},[a._v("#")]),a._v(" 当游览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似与将所有指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。")]),a._v(" "),s("h3",{attrs:{id:"_10-游览器的内核分别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-游览器的内核分别是什么"}},[a._v("#")]),a._v(" 10.游览器的内核分别是什么？")]),a._v(" "),s("ul",[s("li",[a._v("ie：tirdent内核")]),a._v(" "),s("li",[a._v("Firefow： gecko内核")]),a._v(" "),s("li",[a._v("Safari： webkit内核")]),a._v(" "),s("li",[a._v("Opera： 以前是presto内核，现在改用Google Chrome的Blink内核")]),a._v(" "),s("li",[a._v("Chrome： Blink内核(基于webkit，由Google与Opera Software共同开发)")])]),a._v(" "),s("h3",{attrs:{id:"_11-什么叫优雅降级和逐进增强"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-什么叫优雅降级和逐进增强"}},[a._v("#")]),a._v(" 11.什么叫优雅降级和逐进增强？")]),a._v(" "),s("h4",{attrs:{id:"逐进增强-是针对低版本游览器进行构建页面-保证最基本的功能-然后在针对高级游览器进行效果、交互等改进和追加功能达到更好的用户体验。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#逐进增强-是针对低版本游览器进行构建页面-保证最基本的功能-然后在针对高级游览器进行效果、交互等改进和追加功能达到更好的用户体验。"}},[a._v("#")]),a._v(" 逐进增强： 是针对低版本游览器进行构建页面，保证最基本的功能，然后在针对高级游览器进行效果、交互等改进和追加功能达到更好的用户体验。")]),a._v(" "),s("h4",{attrs:{id:"优雅降级-一开始就构建完整的功能-然后再针对低版本游览器进行兼容。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优雅降级-一开始就构建完整的功能-然后再针对低版本游览器进行兼容。"}},[a._v("#")]),a._v(" 优雅降级： 一开始就构建完整的功能，然后再针对低版本游览器进行兼容。")]),a._v(" "),s("h4",{attrs:{id:"区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[a._v("#")]),a._v(" 区别：")]),a._v(" "),s("p",[a._v("1.优雅降级是从复杂的现状开始，并试图减少用户体验的供给；"),s("br"),a._v("\n2.逐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要；"),s("br"),a._v("\n3.降级(功能衰减)意味着往回看；而逐进增强则意味着朝前看，同时保证其根基处于安全地带。")]),a._v(" "),s("h3",{attrs:{id:"_12-sessionstorage、localstorage和cookie之间的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-sessionstorage、localstorage和cookie之间的区别"}},[a._v("#")]),a._v(" 12.sessionStorage、localStorage和cookie之间的区别")]),a._v(" "),s("h4",{attrs:{id:"首先cookie是网景公司的前雇员在1993年发明的。它的主要作用是用于保存登录信息。比如登陆某个网站市场可以看到记住密码。这就是通过cookie中存入一段辨别用户身份的数据来实现的。-然后是sessionstorage-它可以将一部分数据在当前会话中保存下来-刷新页面数据依旧存在。但是当页面关闭后-sessionstorage中存储的数据就会被清空。-而localstorage则是html5标准中新加入的技术-也是用于本地存储。它的存储时间是永久-除非手动清除。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#首先cookie是网景公司的前雇员在1993年发明的。它的主要作用是用于保存登录信息。比如登陆某个网站市场可以看到记住密码。这就是通过cookie中存入一段辨别用户身份的数据来实现的。-然后是sessionstorage-它可以将一部分数据在当前会话中保存下来-刷新页面数据依旧存在。但是当页面关闭后-sessionstorage中存储的数据就会被清空。-而localstorage则是html5标准中新加入的技术-也是用于本地存储。它的存储时间是永久-除非手动清除。"}},[a._v("#")]),a._v(" 首先cookie是网景公司的前雇员在1993年发明的。它的主要作用是用于保存登录信息。比如登陆某个网站市场可以看到记住密码。这就是通过cookie中存入一段辨别用户身份的数据来实现的。 然后是sessionStorage，它可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但是当页面关闭后，sessionStorage中存储的数据就会被清空。 而localStorage则是HTML5标准中新加入的技术，也是用于本地存储。它的存储时间是永久，除非手动清除。")]),a._v(" "),s("h4",{attrs:{id:"那么它们的区别是"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#那么它们的区别是"}},[a._v("#")]),a._v(" 那么它们的区别是：")]),a._v(" "),s("p",[a._v("1.存储大小。cookie一般不会超过4k(因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识)。sessionStorage和localStorage都可以存储5M或更大。"),s("br"),a._v("\n2.数据有效期。cookie一般是由服务器生成，可以设置失效时间。如果没有设置，那么关闭游览器cookie就会失效。如果设置了时间，那么等时间过期后才会失效。 sessionStorage是仅在当前游览器关闭前有效，关闭页面或者游览器会被清除。  localStorage是永久有效，窗口或游览器关闭也会一直保存，除非手动清除，一般用作持久数据。"),s("br"),a._v("\n3.作用域。 cookie和localStorage都是在所有同源窗口中是共享的。sessionStorage则是在同一个游览器窗口是共享的。"),s("br"),a._v("\n4.通信。cookie有十种携带在同源的http请求中，即使不需要，所以cookie在游览器和服务器之间来回传递。如果使用cookie保存过多数据会造成性能问题。而sessionStorage和localStorage都是仅在客户端中保存，不参与和服务器的通信。不会自动把数据发送给服务器。"),s("br"),a._v("\n5.易用性。cookie需要自己进行封装。原生的cookie接口不够友好。而sessionStorage和localStorage原生的接口可以接受，可以封装来对Object和Array有更好的支持。"),s("br"),a._v("\n6.应用场景。cookie判断用户是否登陆过网站，以便实现下次自动登录或记住密码；保存事件信息等。 sessionStorage则是敏感账号一次性登录；单页面用的比较多。localStorage常用于长期登录(判断用户是否已登录)，适合长期保存在本地的数据。")]),a._v(" "),s("h3",{attrs:{id:"_13-html和html5的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-html和html5的区别"}},[a._v("#")]),a._v(" 13.html和html5的区别")]),a._v(" "),s("p",[a._v("1.文档声明区别。HTML是超文本标记语言，一种纯文本类型的语言。HTML5文档声明方便书写，精简，有利于程序员快速的阅读和开发。"),s("br"),a._v("\n2.结构语义区别。HTML没有体现结构语义化的标签。而HTML新增了许多具有语义化的标签。如header\n3.绘图区别。HTML指可伸缩矢量图形，用于定义网络的基于矢量的图形。而HTML5的canvas元素使用脚本(通常使用js)在网页上绘制图形，可以控制画布每一个像素。")]),a._v(" "),s("h3",{attrs:{id:"_14-html5的新特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-html5的新特性"}},[a._v("#")]),a._v(" 14.HTML5的新特性？")]),a._v(" "),s("p",[a._v("1.语义化标签。如header、footer、nav"),s("br"),a._v("\n2.增强型表单。")]),a._v(" "),s("ul",[s("li",[a._v("HTML5拥有多个新的表单input输入类型。提供了更好的输入控制和验证。如date、datetime、email、search、tel、time、url。")]),a._v(" "),s("li",[a._v("新增表单元素。datalist、keygen、output")]),a._v(" "),s("li",[a._v("新增表单属性。placehoder(输入框默认提示语，在用户输入内容后消失)。required(是一个boolean属性，要求填写的输入域不能为空)。min和max属性(设置了元素最大值和最小值)。width和height属性(类似与image标签的宽度和高度)。autofocus属性(也是一个boolean属性。规定在页面加载时，域自动地获取焦点)。")])]),a._v(" "),s("p",[a._v("3.音频和视频。即使用audio元素和video元素"),s("br"),a._v("\n4.canvas图形。"),s("br"),a._v("\n5.svg绘图。"),s("br"),a._v("\n6.地理定位。"),s("br"),a._v("\n7.拖放API。"),s("br"),a._v("\n8.Web Worker。当在HTML页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。"),s("br"),a._v("\n9.Web Storage。 本地存储。"),s("br"),a._v("\n10.WebSocket。")]),a._v(" "),s("h3",{attrs:{id:"_15-在css-js代码上线之后开发人员经常回优化性能-从用户刷新网页开始-一次js请求一般情况下有哪些地方会有缓存处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-在css-js代码上线之后开发人员经常回优化性能-从用户刷新网页开始-一次js请求一般情况下有哪些地方会有缓存处理"}},[a._v("#")]),a._v(" 15.在css/js代码上线之后开发人员经常回优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？")]),a._v(" "),s("h4",{attrs:{id:"dns缓存-cdn缓存-游览器缓存-服务器缓存。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns缓存-cdn缓存-游览器缓存-服务器缓存。"}},[a._v("#")]),a._v(" dns缓存，cdn缓存，游览器缓存，服务器缓存。")]),a._v(" "),s("h2",{attrs:{id:"css"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[a._v("#")]),a._v(" CSS")]),a._v(" "),s("h3",{attrs:{id:"_1-什么是css"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是css"}},[a._v("#")]),a._v(" 1.什么是CSS？")]),a._v(" "),s("h4",{attrs:{id:"css-全称cascading-style-sheets-层叠样式表。是一种用来表现html和xml等文件样式的计算机语言。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-全称cascading-style-sheets-层叠样式表。是一种用来表现html和xml等文件样式的计算机语言。"}},[a._v("#")]),a._v(" CSS，全称Cascading Style Sheets，层叠样式表。是一种用来表现HTML和XML等文件样式的计算机语言。")]),a._v(" "),s("h3",{attrs:{id:"_2-如何居中div"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何居中div"}},[a._v("#")]),a._v(" 2.如何居中div？")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("水平居中"),s("br"),a._v("\n1.已知宽度，block元素。设置固定width，margin: 0 auto;"),s("br"),a._v("\n2.已知宽度，决定定位居中。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("div{\n  position: absolute;\n  width: 300px; \n  height: 300px; \n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  margin: auto;\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br")])]),s("p",[a._v("3.未知宽度。 父级设置text-align:center; 自己设置 display: inline-block;")])]),a._v(" "),s("li",[s("p",[a._v("水平垂直居中"),s("br"),a._v("\n1.确定容器宽高，利用相对或绝对定位然后设置margin值；")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("  div{\n    position: relative;\n    width: 400px;\n    height: 400px;\n    left: 50%;\n    margin-left: -200px;\n    top: 50%;\n    margin-top: -200px;\n  }\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("p",[a._v("2.不确定容器宽高，利用transform属性；")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("  div{\n    position: absolute;\n    top: 50%;\n    left: 50%; \n    transform: translate(-50%, -50%);\n  }\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("p",[a._v("3.flex布局； 需要考虑兼容性。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\x3c!-- 父级样式 --\x3e\n  .container{\n    display: flex;\n    align-items: center; \n    justifu-content: center;\n  }\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("p",[a._v("4.inline-block；父级设置text-align: center；设置行高与父级高度一致；自己设置display: inline-block；为行内块元素然后设置vertical-align: middle;")])])]),a._v(" "),s("h3",{attrs:{id:"_3-css选择符有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-css选择符有哪些"}},[a._v("#")]),a._v(" 3.CSS选择符有哪些？")]),a._v(" "),s("p",[a._v("1.id选择器；"),s("br"),a._v("\n2.类选择器；"),s("br"),a._v("\n3.标签选择器；"),s("br"),a._v("\n4.紧邻同胞选择器 h1 + p；"),s("br"),a._v("\n5.一般同胞选择器 h1 ~ p；"),s("br"),a._v("\n6.子选择器 ul > li；"),s("br"),a._v("\n7.后代选择器 li a；"),s("br"),a._v("\n8.通配符选择器 *；"),s("br"),a._v("\n9.属性选择器[name='xxx']；"),s("br"),a._v("\n10.伪类选择器a:hover；")]),a._v(" "),s("h3",{attrs:{id:"_4-哪些属性可以继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-哪些属性可以继承"}},[a._v("#")]),a._v(" 4.哪些属性可以继承")]),a._v(" "),s("ul",[s("li",[a._v("所有元素可以继承： visbility、cursor")]),a._v(" "),s("li",[a._v("内联元素可以继承： color、letter-spacing、white-space、line-height、font、text-transform、direction")]),a._v(" "),s("li",[a._v("块状元素可以继承： text-indent、text-align")])]),a._v(" "),s("h3",{attrs:{id:"_5-css优先级算法如何计算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-css优先级算法如何计算"}},[a._v("#")]),a._v(" 5.CSS优先级算法如何计算？")]),a._v(" "),s("h4",{attrs:{id:"行间样式的特殊性可以以1000为单位-id选择器的特殊性值以100为单位-类选择器、属性选择器或伪类以10为单位。元素和伪元素以1为单位。通配符选择器的特殊性以0为单位最小。-important则是最大。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行间样式的特殊性可以以1000为单位-id选择器的特殊性值以100为单位-类选择器、属性选择器或伪类以10为单位。元素和伪元素以1为单位。通配符选择器的特殊性以0为单位最小。-important则是最大。"}},[a._v("#")]),a._v(" 行间样式的特殊性可以以1000为单位；id选择器的特殊性值以100为单位；类选择器、属性选择器或伪类以10为单位。元素和伪元素以1为单位。通配符选择器的特殊性以0为单位最小。!important则是最大。")]),a._v(" "),s("h4",{attrs:{id:"优先级就近原则-同权重情况下样式定义最近者为准-载入样式以最后载入的定位为准。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优先级就近原则-同权重情况下样式定义最近者为准-载入样式以最后载入的定位为准。"}},[a._v("#")]),a._v(" 优先级就近原则，同权重情况下样式定义最近者为准； 载入样式以最后载入的定位为准。")]),a._v(" "),s("h3",{attrs:{id:"_6-讲讲标准的css盒子模型和低版本ie的盒子模型有什么不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-讲讲标准的css盒子模型和低版本ie的盒子模型有什么不同"}},[a._v("#")]),a._v(" 6.讲讲标准的CSS盒子模型和低版本IE的盒子模型有什么不同？")]),a._v(" "),s("h4",{attrs:{id:"标准盒模型-宽度-内容的宽度-content-border-padding-margin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标准盒模型-宽度-内容的宽度-content-border-padding-margin"}},[a._v("#")]),a._v(" 标准盒模型： 宽度 = 内容的宽度(content) + border + padding + margin")]),a._v(" "),s("h4",{attrs:{id:"低版本ie盒模型-宽度-内容的宽度-content-border-padding-margin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#低版本ie盒模型-宽度-内容的宽度-content-border-padding-margin"}},[a._v("#")]),a._v(" 低版本IE盒模型： 宽度 = 内容的宽度(content+border+padding) + margin")]),a._v(" "),s("h3",{attrs:{id:"_7-讲讲box-sizing属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-讲讲box-sizing属性"}},[a._v("#")]),a._v(" 7.讲讲box-sizing属性？")]),a._v(" "),s("h4",{attrs:{id:"用来控制元素的盒子模型的解析模式-默认为content-box。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用来控制元素的盒子模型的解析模式-默认为content-box。"}},[a._v("#")]),a._v(" 用来控制元素的盒子模型的解析模式，默认为content-box。")]),a._v(" "),s("h4",{attrs:{id:"content-box-w3c的标准盒子模型-设置元素的height-width属性指的是content部分的高-宽。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#content-box-w3c的标准盒子模型-设置元素的height-width属性指的是content部分的高-宽。"}},[a._v("#")]),a._v(" content-box：W3C的标准盒子模型，设置元素的height/width属性指的是content部分的高/宽。")]),a._v(" "),s("h4",{attrs:{id:"border-box-ie传统盒子模型。设置元素的height-width属性指的是border-padding-content部分的宽高。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#border-box-ie传统盒子模型。设置元素的height-width属性指的是border-padding-content部分的宽高。"}},[a._v("#")]),a._v(" border-box：IE传统盒子模型。设置元素的height/width属性指的是border+padding+content部分的宽高。")]),a._v(" "),s("h3",{attrs:{id:"_8-css3有哪些新特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-css3有哪些新特性"}},[a._v("#")]),a._v(" 8.CSS3有哪些新特性？")]),a._v(" "),s("p",[a._v("1.RGBA和透明度；"),s("br"),a._v("\n2.多背景(background-image可以设置多个url或linear-gradient)；"),s("br"),a._v("\n3.线性渐变(gradient);"),s("br"),a._v("\n4.文字阴影和盒阴影；"),s("br"),a._v("\n5.(transform)：旋转rotate、缩放scale、倾斜skew、平移translate；"),s("br"),a._v("\n6.圆角(边框半径)： border-radius 属性用于创建圆角；"),s("br"),a._v("\n7.边框图片： border-image;"),s("br"),a._v("\n8.动画(animation)和过渡效果(transition)；"),s("br"),a._v("\n9.媒体查询：@media\n10.新增各种CSS选择器、伪类；")]),a._v(" "),s("h3",{attrs:{id:"_9-为什么要初始化css样式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-为什么要初始化css样式"}},[a._v("#")]),a._v(" 9.为什么要初始化CSS样式？")]),a._v(" "),s("h4",{attrs:{id:"因为游览器的兼容问题-不同游览器对有些标签的默认值是不同的-如果没对css初始化往往会出现游览器之间的页面显示差异。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#因为游览器的兼容问题-不同游览器对有些标签的默认值是不同的-如果没对css初始化往往会出现游览器之间的页面显示差异。"}},[a._v("#")]),a._v(" 因为游览器的兼容问题，不同游览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现游览器之间的页面显示差异。")]),a._v(" "),s("h3",{attrs:{id:"_10-display-none与visibility-hidden的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-display-none与visibility-hidden的区别"}},[a._v("#")]),a._v(" 10.display:none与visibility:hidden的区别？")]),a._v(" "),s("h4",{attrs:{id:"display-none是不显示对应的元素-在文档布局中不在分配空间-回流-重绘-。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#display-none是不显示对应的元素-在文档布局中不在分配空间-回流-重绘-。"}},[a._v("#")]),a._v(" display：none是不显示对应的元素，在文档布局中不在分配空间(回流 + 重绘)。")]),a._v(" "),s("h4",{attrs:{id:"visibility-hidden隐藏对应元素-在文档布局中仍保留原来的空间-重绘-。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#visibility-hidden隐藏对应元素-在文档布局中仍保留原来的空间-重绘-。"}},[a._v("#")]),a._v(" visibility:hidden隐藏对应元素，在文档布局中仍保留原来的空间(重绘)。")]),a._v(" "),s("h3",{attrs:{id:"_11-对bfc规范的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-对bfc规范的理解"}},[a._v("#")]),a._v(" 11.对BFC规范的理解？")]),a._v(" "),s("h4",{attrs:{id:"bfc就是一种属性-触发了这个属性的容器生成了一种特殊的格式化上下文-块级上下文。在这个容器中-子元素都是普通流进行渲染。容器内的所有元素可以说是一个独立的上下文关系-无论在里面做什么都不会影响容器外的元素结构。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bfc就是一种属性-触发了这个属性的容器生成了一种特殊的格式化上下文-块级上下文。在这个容器中-子元素都是普通流进行渲染。容器内的所有元素可以说是一个独立的上下文关系-无论在里面做什么都不会影响容器外的元素结构。"}},[a._v("#")]),a._v(" BFC就是一种属性，触发了这个属性的容器生成了一种特殊的格式化上下文，块级上下文。在这个容器中，子元素都是普通流进行渲染。容器内的所有元素可以说是一个独立的上下文关系，无论在里面做什么都不会影响容器外的元素结构。")]),a._v(" "),s("h4",{attrs:{id:"触发条件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#触发条件"}},[a._v("#")]),a._v(" 触发条件：")]),a._v(" "),s("p",[a._v("1.根元素，即html；"),s("br"),a._v("\n2.float的值不为none；"),s("br"),a._v("\n3.overflow的值不为visible；"),s("br"),a._v("\n4.display的值为inline-block、table-cell、table-caption；"),s("br"),a._v("\n5.position的值为absolute或fixed。")]),a._v(" "),s("h4",{attrs:{id:"用途"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用途"}},[a._v("#")]),a._v(" 用途：")]),a._v(" "),s("p",[a._v("1.使用BFC解决外边距塌陷；"),s("br"),a._v("\n2.解决浮动元素带来的高度塌陷；"),s("br"),a._v("\n3.防止文本环绕浮动元素实现自适应布局。")]),a._v(" "),s("h3",{attrs:{id:"_12-游览器怎么解析css选择器的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-游览器怎么解析css选择器的"}},[a._v("#")]),a._v(" 12.游览器怎么解析CSS选择器的？")]),a._v(" "),s("h4",{attrs:{id:"css选择器的解析式从右向左解析的。因为如果从左向右的匹配-发现不符合规则-需要进行回溯-这样会损失很多性能。而从右向左匹配-会先找到所有最右节点-对于每一个节点-向上寻找父节点直到找到根元素或满足条件的匹配规则-则结束掉这个分支的遍历。这两种匹配规则的性能差别很大。-在css解析完毕后-需要将解析的结果与dom-tree的内容一起进行分析建立一颗render-tree-最终用来进行绘图。在建立render-tree时-游览器就要为每个dom-tree中的元素根据css的解析结果来确定生成怎样的render-tree。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css选择器的解析式从右向左解析的。因为如果从左向右的匹配-发现不符合规则-需要进行回溯-这样会损失很多性能。而从右向左匹配-会先找到所有最右节点-对于每一个节点-向上寻找父节点直到找到根元素或满足条件的匹配规则-则结束掉这个分支的遍历。这两种匹配规则的性能差别很大。-在css解析完毕后-需要将解析的结果与dom-tree的内容一起进行分析建立一颗render-tree-最终用来进行绘图。在建立render-tree时-游览器就要为每个dom-tree中的元素根据css的解析结果来确定生成怎样的render-tree。"}},[a._v("#")]),a._v(" CSS选择器的解析式从右向左解析的。因为如果从左向右的匹配，发现不符合规则，需要进行回溯，这样会损失很多性能。而从右向左匹配，会先找到所有最右节点，对于每一个节点，向上寻找父节点直到找到根元素或满足条件的匹配规则，则结束掉这个分支的遍历。这两种匹配规则的性能差别很大。 在CSS解析完毕后，需要将解析的结果与DOM Tree的内容一起进行分析建立一颗Render Tree，最终用来进行绘图。在建立Render Tree时，游览器就要为每个DOM Tree中的元素根据CSS的解析结果来确定生成怎样的Render Tree。")]),a._v(" "),s("h3",{attrs:{id:"_13-什么是响应式设计-响应式设计的基本原理是什么-如何兼容低版本ie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-什么是响应式设计-响应式设计的基本原理是什么-如何兼容低版本ie"}},[a._v("#")]),a._v(" 13.什么是响应式设计？ 响应式设计的基本原理是什么？ 如何兼容低版本ie")]),a._v(" "),s("h4",{attrs:{id:"响应式网站设计是一个网站可以兼容多个终端-而不是为每一个终端做一个特定的版本。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应式网站设计是一个网站可以兼容多个终端-而不是为每一个终端做一个特定的版本。"}},[a._v("#")]),a._v(" 响应式网站设计是一个网站可以兼容多个终端，而不是为每一个终端做一个特定的版本。")]),a._v(" "),s("h4",{attrs:{id:"基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。"}},[a._v("#")]),a._v(" 基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。")]),a._v(" "),s("h4",{attrs:{id:"页面头部必须有meta声明的viewport。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面头部必须有meta声明的viewport。"}},[a._v("#")]),a._v(" 页面头部必须有meta声明的viewport。")]),a._v(" "),s("h3",{attrs:{id:"_14-讲讲flexbox弹性盒布局模型。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-讲讲flexbox弹性盒布局模型。"}},[a._v("#")]),a._v(" 14.讲讲flexbox弹性盒布局模型。")]),a._v(" "),s("h4",{attrs:{id:"flex布局一般称作弹性布局。任何一个容器都可以指定为flex布局。我们称这个容器叫flex容器。它的所有子元素称为flex项目。容器默认存在两根轴-水平的主轴和垂直的交叉轴。主轴开始的未知叫做main-start-结束的位置叫做main-end-交叉轴开始的位置叫做cross-start-结束的位置叫做cross-end。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flex布局一般称作弹性布局。任何一个容器都可以指定为flex布局。我们称这个容器叫flex容器。它的所有子元素称为flex项目。容器默认存在两根轴-水平的主轴和垂直的交叉轴。主轴开始的未知叫做main-start-结束的位置叫做main-end-交叉轴开始的位置叫做cross-start-结束的位置叫做cross-end。"}},[a._v("#")]),a._v(" flex布局一般称作弹性布局。任何一个容器都可以指定为flex布局。我们称这个容器叫flex容器。它的所有子元素称为flex项目。容器默认存在两根轴，水平的主轴和垂直的交叉轴。主轴开始的未知叫做main start，结束的位置叫做main end；交叉轴开始的位置叫做cross start，结束的位置叫做cross end。")]),a._v(" "),s("h4",{attrs:{id:"容器有六个属性-分别是"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器有六个属性-分别是"}},[a._v("#")]),a._v(" 容器有六个属性 分别是：")]),a._v(" "),s("p",[a._v("1.flex-direction： 决定主轴是哪一根及他们的方向。"),s("br"),a._v("\n2.flex-warp： 决定项目如果在一条轴线排不下时，如何换行。默认情况下项目都排在一条轴线上。"),s("br"),a._v("\n3.flex-flow： 是flex-direction和flex-wrap的简写。"),s("br"),a._v("\n4.justify-content： 定义了项目在主轴上的对齐方式。"),s("br"),a._v("\n5.align-items： 定义了项目在交叉轴的对齐方式。"),s("br"),a._v("\n6.align-content： 定义了多根轴线的对齐方式。如果只有一根轴线，该属性不起作用。")]),a._v(" "),s("h4",{attrs:{id:"项目也有六个属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#项目也有六个属性"}},[a._v("#")]),a._v(" 项目也有六个属性：")]),a._v(" "),s("p",[a._v("1.order：属性定义项目的排列顺序，数值越小，排列越靠前。默认为0。"),s("br"),a._v("\n2.flex-grow：属性定义项目的伸缩比例。"),s("br"),a._v("\n3.flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。"),s("br"),a._v("\n4.flex-basis：定义了项目在不伸缩情况下的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度。默认是auto。"),s("br"),a._v("\n5.flex：是flex-grow和flex-shrink和flex-basis的简写，默认值为 0 1 auto。该属性有两个快捷值，auto(1 1 auto)即等分，可缩小，宽度默认。none(0 0 auto)即不放大，不缩小，宽度默认。"),s("br"),a._v("\n6.align-self：允许单个项目与其他项目不一样的对齐方式，可覆盖父容器align-items属性，默认值为auto，表示继承父级的align-items属性，如果没有父元素，则等同于stretch。")]),a._v(" "),s("h4",{attrs:{id:"需要注意-webkit的内核需要加上-webkit-前缀。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#需要注意-webkit的内核需要加上-webkit-前缀。"}},[a._v("#")]),a._v(" 需要注意，Webkit的内核需要加上-webkit-前缀。")]),a._v(" "),s("h3",{attrs:{id:"_15-等分布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-等分布局"}},[a._v("#")]),a._v(" 15.等分布局")]),a._v(" "),s("p",[a._v("1.子级盒子按百分比均分，设置行内块属性，给每个子级浮动效果或者父级设置font-size:0；解决行内块间隙问题。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('.item{\n  display: inline-block;\n  float: left;\n  width: 33.33%;\n  height: 300px;\n}\n\n<div class="container">\n  <div class="item"></div>\n  <div class="item"></div>\n  <div class="item"></div>\n</div>\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br")])]),s("p",[a._v("2.使用table的方式。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('.container{\n  display: table;\n  width: 100%;\n}\n.item{\n  display: table-cell;\n}\n<div class="container">\n  <div class="item"></div>\n  <div class="item"></div>\n  <div class="item"></div>\n</div>\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br")])]),s("h3",{attrs:{id:"_16-等高布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-等高布局"}},[a._v("#")]),a._v(" 16.等高布局")]),a._v(" "),s("h4",{attrs:{id:"padding补偿法。使用padding加上margin负值达到效果哦。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#padding补偿法。使用padding加上margin负值达到效果哦。"}},[a._v("#")]),a._v(" padding补偿法。使用padding加上margin负值达到效果哦。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('.container{\n  overflow: hidden;\n}\n.item{\n  float: left;\n  padding-bottom: 9999px;\n  margin-bottom: -9999px;\n}\n\n<div class="container">\n  \x3c!-- 假设下面每个盒子的内容不等高 --\x3e\n  <div class="item"></div>\n  <div class="item"></div>\n  <div class="item"></div>\n</div>\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br")])]),s("h3",{attrs:{id:"_17-两列自适应布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-两列自适应布局"}},[a._v("#")]),a._v(" 17.两列自适应布局")]),a._v(" "),s("p",[a._v("1.float加margin")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('.left{\n  float: left;\n  width: 100px;\n}\n.right{\n  margin-left: 100px;\n}\n<div class="outer">\n  <div class="left"></div>\n  <div class="right"></div>\n</div>\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br")])]),s("p",[a._v("2.left加BFC")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('.left{\n  float: left;\n  width: 100px;\n}\n.right{\n  overflow: hidden;\n}\n<div class="outer">\n  <div class="left"></div>\n  <div class="right"></div>\n</div>\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br")])]),s("h3",{attrs:{id:"_18-三列自适应布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-三列自适应布局"}},[a._v("#")]),a._v(" 18.三列自适应布局")]),a._v(" "),s("p",[a._v("前两种和上面两列自适应布局方法一样， 就是加一个有浮动的盒子 通过margin值或者BFC来实现。省略了。")]),a._v(" "),s("h4",{attrs:{id:"圣杯布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#圣杯布局"}},[a._v("#")]),a._v(" 圣杯布局")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('.outer{\n  padding-left: 200px;\n  padding-right: 300px;\n}\n.center{\n  float: left;\n  width: 100%;\n}\n.left{\n  position: relative;\n  width: 200px;\n  margin-left: -100%;\n  left: -200px;\n  float: left;\n  background-color: red;\n}\n.right{\n  float: left;\n  position: relative;\n  width: 300px;\n  margin-left: -300px;\n  left: 300px;\n  background-color: blue;\n}\n<div class="outer">\n  <div class="center">center</div>\n  <div class="left">left</div>\n  <div class="right">right</div>\n</div>\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br")])]),s("h4",{attrs:{id:"双飞翼布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双飞翼布局"}},[a._v("#")]),a._v(" 双飞翼布局")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('\n.center {\n  float: left;\n  width: 100%;\n  height: 100px;\n}\n\n.center-box {\n  padding-left: 200px;\n  padding-right: 300px;\n}\n\n.left {\n  width: 200px;\n  margin-left: -100%;\n  float: left;\n  background-color: red;\n}\n\n.right {\n  float: left;\n  width: 300px;\n  margin-left: -300px;\n  background-color: blue;\n}\n<div class="outer">\n  <div class="center">\n    <div class="center-box"></div>\n  </div>\n  <div class="left">left</div>\n  <div class="right">right</div>\n</div>\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br"),s("span",{staticClass:"line-number"},[a._v("27")]),s("br"),s("span",{staticClass:"line-number"},[a._v("28")]),s("br"),s("span",{staticClass:"line-number"},[a._v("29")]),s("br"),s("span",{staticClass:"line-number"},[a._v("30")]),s("br"),s("span",{staticClass:"line-number"},[a._v("31")]),s("br"),s("span",{staticClass:"line-number"},[a._v("32")]),s("br")])]),s("h3",{attrs:{id:"_19-transform、translate、transition分别时什么属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-transform、translate、transition分别时什么属性"}},[a._v("#")]),a._v(" 19.transform、translate、transition分别时什么属性？")]),a._v(" "),s("h4",{attrs:{id:"transform是指变换、变形。translate是transform的属性值-是指元素进行2d-3d维度上位移或者范围变换。transition是指过渡效果-一般理解为简单的动画-需要有触发条件。在一定时间内-一组css属性变换到另一组css属性的动画展示过程。-可以设置4个值-需要变换的属性、变换需要的时间、控制动画速度变化、延期多少时间后开始执行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#transform是指变换、变形。translate是transform的属性值-是指元素进行2d-3d维度上位移或者范围变换。transition是指过渡效果-一般理解为简单的动画-需要有触发条件。在一定时间内-一组css属性变换到另一组css属性的动画展示过程。-可以设置4个值-需要变换的属性、变换需要的时间、控制动画速度变化、延期多少时间后开始执行"}},[a._v("#")]),a._v(" transform是指变换、变形。translate是transform的属性值，是指元素进行2D/3D维度上位移或者范围变换。transition是指过渡效果，一般理解为简单的动画，需要有触发条件。在一定时间内，一组css属性变换到另一组css属性的动画展示过程。 可以设置4个值， 需要变换的属性、变换需要的时间、控制动画速度变化、延期多少时间后开始执行")]),a._v(" "),s("h3",{attrs:{id:"js"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[a._v("#")]),a._v(" JS")]),a._v(" "),s("h4",{attrs:{id:"_1-讲讲事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-讲讲事件循环"}},[a._v("#")]),a._v(" 1.讲讲事件循环")]),a._v(" "),s("h4",{attrs:{id:"首先js是单线程语言-同一个时间只能做一件事。所有任务需要排队-前一个任务结束-才会执行下一个任务。如果前一个任务耗时很长-后面的任务就不得不一直等待。所以设计者将所有任务分为两种-一个是同步任务-另一个是异步任务。在所有同步任务执行完之前-任何的异步任务是不会执行的。在js执行同步任务时-会进入主线程。执行异步任务时-会把这个异步函数放入一个由c-实现的webapis中-比如定时器settimeout-主线程继续执行-异步函数再webapis同步执行-当定时器的时间到了-会产生一个回调函数-这个回调函数会被放置在任务队列中-这里有一个event-loop的监听器-一直监听主线程的调用栈和任务队列-当主线程调用栈为空时-会去任务队列中查看是否还有任务等待执行-如果有-就把任务队列中的第一个任务推入调用栈中继续执行-执行完后会去查看当前任务的微任务-直到所有的微任务执行完了-就会弹出调用栈-然后再次由event-loop监听调用栈为空-去查看任务队列-这样循环下去-直到调用栈为空-任务队列也为空。-这个过程就叫做事件循环。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#首先js是单线程语言-同一个时间只能做一件事。所有任务需要排队-前一个任务结束-才会执行下一个任务。如果前一个任务耗时很长-后面的任务就不得不一直等待。所以设计者将所有任务分为两种-一个是同步任务-另一个是异步任务。在所有同步任务执行完之前-任何的异步任务是不会执行的。在js执行同步任务时-会进入主线程。执行异步任务时-会把这个异步函数放入一个由c-实现的webapis中-比如定时器settimeout-主线程继续执行-异步函数再webapis同步执行-当定时器的时间到了-会产生一个回调函数-这个回调函数会被放置在任务队列中-这里有一个event-loop的监听器-一直监听主线程的调用栈和任务队列-当主线程调用栈为空时-会去任务队列中查看是否还有任务等待执行-如果有-就把任务队列中的第一个任务推入调用栈中继续执行-执行完后会去查看当前任务的微任务-直到所有的微任务执行完了-就会弹出调用栈-然后再次由event-loop监听调用栈为空-去查看任务队列-这样循环下去-直到调用栈为空-任务队列也为空。-这个过程就叫做事件循环。"}},[a._v("#")]),a._v(" 首先js是单线程语言，同一个时间只能做一件事。所有任务需要排队，前一个任务结束，才会执行下一个任务。如果前一个任务耗时很长， 后面的任务就不得不一直等待。所以设计者将所有任务分为两种，一个是同步任务，另一个是异步任务。在所有同步任务执行完之前，任何的异步任务是不会执行的。在js执行同步任务时，会进入主线程。执行异步任务时，会把这个异步函数放入一个由C++实现的WebApis中，比如定时器settimeout，主线程继续执行，异步函数再WebApis同步执行，当定时器的时间到了，会产生一个回调函数，这个回调函数会被放置在任务队列中，这里有一个event loop的监听器，一直监听主线程的调用栈和任务队列， 当主线程调用栈为空时，会去任务队列中查看是否还有任务等待执行，如果有，就把任务队列中的第一个任务推入调用栈中继续执行，执行完后会去查看当前任务的微任务，直到所有的微任务执行完了，就会弹出调用栈，然后再次由event loop监听调用栈为空，去查看任务队列，这样循环下去，直到调用栈为空，任务队列也为空。 这个过程就叫做事件循环。")]),a._v(" "),s("h3",{attrs:{id:"_2-javascript的typeof返回哪些数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-javascript的typeof返回哪些数据类型"}},[a._v("#")]),a._v(" 2.JavaScript的typeof返回哪些数据类型？")]),a._v(" "),s("h4",{attrs:{id:"typeof可以判断出-string、number、boolean、undefined、symbol-但判断null时为object-判断数组和对象时也是object。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#typeof可以判断出-string、number、boolean、undefined、symbol-但判断null时为object-判断数组和对象时也是object。"}},[a._v("#")]),a._v(" typeof可以判断出 string、number、boolean、undefined、symbol，但判断null时为object，判断数组和对象时也是object。")]),a._v(" "),s("h3",{attrs:{id:"_3-举例3种强制类型转换和2种隐式转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-举例3种强制类型转换和2种隐式转换"}},[a._v("#")]),a._v(" 3.举例3种强制类型转换和2种隐式转换？")]),a._v(" "),s("h4",{attrs:{id:"强制-parseint、parsefloat、number。-隐式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强制-parseint、parsefloat、number。-隐式"}},[a._v("#")]),a._v(" 强制:parseInt、parseFloat、number。 隐式 == ===")]),a._v(" "),s("h3",{attrs:{id:"_4-split和join的区别。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-split和join的区别。"}},[a._v("#")]),a._v(" 4.split和join的区别。")]),a._v(" "),s("h4",{attrs:{id:"split是将字符串切割成数组的形式。join是把数组转换成字符串。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#split是将字符串切割成数组的形式。join是把数组转换成字符串。"}},[a._v("#")]),a._v(" split是将字符串切割成数组的形式。join是把数组转换成字符串。")]),a._v(" "),s("h3",{attrs:{id:"_5-数组方法pop-push-unshift-shift"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-数组方法pop-push-unshift-shift"}},[a._v("#")]),a._v(" 5.数组方法pop push unshift shift")]),a._v(" "),s("h4",{attrs:{id:"push是尾部添加-pop是尾部删除。unshift是头部添加-shift是头部删除。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#push是尾部添加-pop是尾部删除。unshift是头部添加-shift是头部删除。"}},[a._v("#")]),a._v(" push是尾部添加，pop是尾部删除。unshift是头部添加，shift是头部删除。")]),a._v(" "),s("h3",{attrs:{id:"_6-什么是闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-什么是闭包"}},[a._v("#")]),a._v(" 6.什么是闭包？")]),a._v(" "),s("h4",{attrs:{id:"闭包是指有权访问另外一个函数作用域中的变量函数。因为作用域和垃圾回收机制的关系-在函数中声明的变量-在函数外是获取不到的-如果我们想获取函数内的变量-就可以通过闭包来获取。需要注意的是-闭包使用不当会导致内存泄漏。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包是指有权访问另外一个函数作用域中的变量函数。因为作用域和垃圾回收机制的关系-在函数中声明的变量-在函数外是获取不到的-如果我们想获取函数内的变量-就可以通过闭包来获取。需要注意的是-闭包使用不当会导致内存泄漏。"}},[a._v("#")]),a._v(" 闭包是指有权访问另外一个函数作用域中的变量函数。因为作用域和垃圾回收机制的关系，在函数中声明的变量，在函数外是获取不到的，如果我们想获取函数内的变量，就可以通过闭包来获取。需要注意的是，闭包使用不当会导致内存泄漏。")]),a._v(" "),s("h4",{attrs:{id:"优点-避免全局变量的污染和缓存变量。-缺点-消耗内存-增加内存使用量。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点-避免全局变量的污染和缓存变量。-缺点-消耗内存-增加内存使用量。"}},[a._v("#")]),a._v(" 优点： 避免全局变量的污染和缓存变量。  缺点： 消耗内存，增加内存使用量。")]),a._v(" "),s("h3",{attrs:{id:"_7-如何阻止默认事件-如何阻止事件冒泡。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何阻止默认事件-如何阻止事件冒泡。"}},[a._v("#")]),a._v(" 7.如何阻止默认事件/如何阻止事件冒泡。")]),a._v(" "),s("h4",{attrs:{id:"_1-return-false。-2-event-preventdefault"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-return-false。-2-event-preventdefault"}},[a._v("#")]),a._v(" 1.return false。 2.event.preventDefault();")]),a._v(" "),s("h4",{attrs:{id:"_1-event-stoppropagation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-event-stoppropagation"}},[a._v("#")]),a._v(" 1.event.stopPropagation();")]),a._v(" "),s("h3",{attrs:{id:"_8-document-load和-document-ready的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-document-load和-document-ready的区别"}},[a._v("#")]),a._v(" 8.document.load和$(document).ready的区别")]),a._v(" "),s("h4",{attrs:{id:"load是再结构和样式-外部js及图片加载完才执行-是js方法。而ready是dom树创建完成后就执行的方法-是jq方法。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#load是再结构和样式-外部js及图片加载完才执行-是js方法。而ready是dom树创建完成后就执行的方法-是jq方法。"}},[a._v("#")]),a._v(" load是再结构和样式，外部js及图片加载完才执行，是js方法。而ready是dom树创建完成后就执行的方法，是jq方法。")]),a._v(" "),s("h3",{attrs:{id:"_9-javascript的事件流模型都有什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-javascript的事件流模型都有什么"}},[a._v("#")]),a._v(" 9.JavaScript的事件流模型都有什么")]),a._v(" "),s("ul",[s("li",[a._v("事件冒泡： 事件开始由最具体的元素接受，然后逐级向上传播")]),a._v(" "),s("li",[a._v("事件捕捉： 事件由最不具体的节点先接收，然后逐级向下，一直到最具体的。")]),a._v(" "),s("li",[a._v("DOM事件流： 三个阶段： 事件捕捉、目标阶段、事件冒泡。")])]),a._v(" "),s("h3",{attrs:{id:"_10-null和undefined的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-null和undefined的区别"}},[a._v("#")]),a._v(" 10.null和undefined的区别？")]),a._v(" "),s("h4",{attrs:{id:"null表示一个无的对象-转换为数值是0-undefined是一个表示无的原始值-转换为数值是nan。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#null表示一个无的对象-转换为数值是0-undefined是一个表示无的原始值-转换为数值是nan。"}},[a._v("#")]),a._v(" null表示一个无的对象，转换为数值是0，undefined是一个表示无的原始值，转换为数值是NaN。")]),a._v(" "),s("h4",{attrs:{id:"当声明的变量还没有被初始化时-变量的默认值是undefined。null用来表示尚未存在的对象。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当声明的变量还没有被初始化时-变量的默认值是undefined。null用来表示尚未存在的对象。"}},[a._v("#")]),a._v(" 当声明的变量还没有被初始化时，变量的默认值是undefined。null用来表示尚未存在的对象。")]),a._v(" "),s("h4",{attrs:{id:"当下面几种情况是会出现undefined。1-变量被声明了但是没有赋值。2-调用函数时-应该提供的参数没有提供-该参数为undefined。3-对象没有赋值的属性。4。函数没有返回值-默认返回undefined。-而null存在于-作为函数的参数-表示该函数的参数不是对象。作为对象原型链的终点。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当下面几种情况是会出现undefined。1-变量被声明了但是没有赋值。2-调用函数时-应该提供的参数没有提供-该参数为undefined。3-对象没有赋值的属性。4。函数没有返回值-默认返回undefined。-而null存在于-作为函数的参数-表示该函数的参数不是对象。作为对象原型链的终点。"}},[a._v("#")]),a._v(" 当下面几种情况是会出现undefined。1.变量被声明了但是没有赋值。2.调用函数时，应该提供的参数没有提供，该参数为undefined。3.对象没有赋值的属性。4。函数没有返回值，默认返回undefined。  而null存在于：作为函数的参数，表示该函数的参数不是对象。作为对象原型链的终点。")]),a._v(" "),s("h3",{attrs:{id:"_11-new操作符具体干了什么。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-new操作符具体干了什么。"}},[a._v("#")]),a._v(" 11.new操作符具体干了什么。")]),a._v(" "),s("p",[a._v("1.创建了一个空对象，并且this变量引用该对象，同时还继承了该函数的原型。"),s("br"),a._v("\n2.属性和方法被加入到this引用的对象中。"),s("br"),a._v("\n3.新创建的对象由this所引用，并且最后隐式的返回this。")]),a._v(" "),s("h3",{attrs:{id:"_12-浅拷贝和深拷贝。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-浅拷贝和深拷贝。"}},[a._v("#")]),a._v(" 12.浅拷贝和深拷贝。")]),a._v(" "),s("h4",{attrs:{id:"浅拷贝指的是在修改拷贝的值时-原来的值也会发生变化。而深拷贝则是修改拷贝的值-原来的值不会发生改变。-实现深拷贝的方法-json-parse-json-stringify-obj"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝指的是在修改拷贝的值时-原来的值也会发生变化。而深拷贝则是修改拷贝的值-原来的值不会发生改变。-实现深拷贝的方法-json-parse-json-stringify-obj"}},[a._v("#")]),a._v(" 浅拷贝指的是在修改拷贝的值时，原来的值也会发生变化。而深拷贝则是修改拷贝的值，原来的值不会发生改变。 实现深拷贝的方法： JSON.parse(JSON.stringify(obj));")]),a._v(" "),s("h3",{attrs:{id:"_13-instanceof和isprototypeof的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-instanceof和isprototypeof的区别"}},[a._v("#")]),a._v(" 13.instanceOf和isPrototypeOf的区别")]),a._v(" "),s("h4",{attrs:{id:"instanceof运算符用来检测一个构造函数的prototype是否在一个对象的原型链上。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#instanceof运算符用来检测一个构造函数的prototype是否在一个对象的原型链上。"}},[a._v("#")]),a._v(" instanceOf运算符用来检测一个构造函数的prototype是否在一个对象的原型链上。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\x3c!-- 定义构造函数 --\x3e\nfunction C() {}\nvar o = new C();\no instanceOf C；\n\x3c!-- 检测构造函数C的prototype是否在o的原型链上 --\x3e\n\x3c!-- Object.getPrototypeOf(o) === C.prototype |   => true  --\x3e\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("h4",{attrs:{id:"isprototypeof-方法用于测试一个对象是否存在另一个对象的原型链上。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#isprototypeof-方法用于测试一个对象是否存在另一个对象的原型链上。"}},[a._v("#")]),a._v(" isPrototypeOf()方法用于测试一个对象是否存在另一个对象的原型链上。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\x3c!-- 定义构造函数 --\x3e\nfunction Fee() {}\nfunction Fi() {}\nFi.prototype = new Fee();\nvar Fo = new Fi();\nconsole.log(Fi.prototype.isPrototypeOf(Fo));\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("h4",{attrs:{id:"两者的区别主要是"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两者的区别主要是"}},[a._v("#")]),a._v(" 两者的区别主要是：")]),a._v(" "),s("p",[a._v("A.isPrototypeOf(B) 判断的是A对象是否存在于B对象的原型链之中"),s("br"),a._v("\nA instanceOf B 判断的是B.prototype是否存在于A的原型链之中"),s("br"),a._v("\n如果A.isPrototypeOf(B) 返回true 则 B instanceOf A 一定返回 true")]),a._v(" "),s("h3",{attrs:{id:"_14-什么是原型-原型链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-什么是原型-原型链"}},[a._v("#")]),a._v(" 14.什么是原型，原型链？")]),a._v(" "),s("h4",{attrs:{id:"js中-万物皆对象-除了null和undefined外-每个对象都有原型-它是对象的默认属性和方法。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js中-万物皆对象-除了null和undefined外-每个对象都有原型-它是对象的默认属性和方法。"}},[a._v("#")]),a._v(" Js中，万物皆对象，除了null和undefined外，每个对象都有原型，它是对象的默认属性和方法。")]),a._v(" "),s("h4",{attrs:{id:"每个对象都有一个指向它的原型-prototype-对象的内部链接。这个原型对象又有自己的原型-直到某个对象的原型为null为止-组成这条链的最后一环。这种一级一级的链结构就是原型链。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#每个对象都有一个指向它的原型-prototype-对象的内部链接。这个原型对象又有自己的原型-直到某个对象的原型为null为止-组成这条链的最后一环。这种一级一级的链结构就是原型链。"}},[a._v("#")]),a._v(" 每个对象都有一个指向它的原型(prototype)对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为null为止，组成这条链的最后一环。这种一级一级的链结构就是原型链。")]),a._v(" "),s("h3",{attrs:{id:"_15-构造函数、实例对象和原型对象。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-构造函数、实例对象和原型对象。"}},[a._v("#")]),a._v(" 15.构造函数、实例对象和原型对象。")]),a._v(" "),s("h4",{attrs:{id:"构造函数-prototype可以找到构造函数的原型对象。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数-prototype可以找到构造函数的原型对象。"}},[a._v("#")]),a._v(" 构造函数.prototype可以找到构造函数的原型对象。")]),a._v(" "),s("h4",{attrs:{id:"实例对象-proto-可以找到该实例构造函数的原型对象。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例对象-proto-可以找到该实例构造函数的原型对象。"}},[a._v("#")]),a._v(" 实例对象.__proto__可以找到该实例构造函数的原型对象。")]),a._v(" "),s("h4",{attrs:{id:"构造函数的原型对象-prototype-的构造器-constructor-指向该构造函数。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数的原型对象-prototype-的构造器-constructor-指向该构造函数。"}},[a._v("#")]),a._v(" 构造函数的原型对象(prototype)的构造器(constructor)指向该构造函数。")]),a._v(" "),s("h4",{attrs:{id:"实例对象的-proto-的构造器-constructor-指向该示例的构造函数。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例对象的-proto-的构造器-constructor-指向该示例的构造函数。"}},[a._v("#")]),a._v(" 实例对象的.__proto__的构造器(constructor)指向该示例的构造函数。")]),a._v(" "),s("h3",{attrs:{id:"_16-object-prototype-tostring-call"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-object-prototype-tostring-call"}},[a._v("#")]),a._v(" 16.Object.prototype.toString.call()")]),a._v(" "),s("h4",{attrs:{id:"常用于判断游览器内置对象-对于所有基本的数据类型都能判断-包括null和undefined"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用于判断游览器内置对象-对于所有基本的数据类型都能判断-包括null和undefined"}},[a._v("#")]),a._v(" 常用于判断游览器内置对象，对于所有基本的数据类型都能判断，包括null和undefined")]),a._v(" "),s("h3",{attrs:{id:"_17-array-isarray"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-array-isarray"}},[a._v("#")]),a._v(" 17.Array.isArray()")]),a._v(" "),s("h4",{attrs:{id:"判断是否为数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#判断是否为数组"}},[a._v("#")]),a._v(" 判断是否为数组")]),a._v(" "),s("h3",{attrs:{id:"_18-数组去重的方法。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-数组去重的方法。"}},[a._v("#")]),a._v(" 18.数组去重的方法。")]),a._v(" "),s("p",[a._v("1.ES6的Set")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("let arr = [1,1,2,3,3,4,5];\nlet arr2 = [...new Set(arr)]; \n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("2.reduce()")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("let arr = [1,1,2,3,3,4,5];\nlet arr2 = arr.reduce(function(ar, cur) {\n  if(!ar.includes(cur)) {\n    ar.push(cur)\n  }\n  return ar;\n}, []);\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("p",[a._v("3.filter()")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 这个方法会有一个问题，[1, '1']会被当做相同元素，最终输入[1]\nlet arr = [1,1,2,3,3,4,5];\nleft arr2 = arr.filter(function(item, index) {\n  // indexOf() 方法可返回某个指定的 字符串值 在字符串中首次出现的位置\n  return arr.indexOf(item) === index\n})\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("h3",{attrs:{id:"_19-dom事件有哪些阶段-谈谈对事件代理的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-dom事件有哪些阶段-谈谈对事件代理的理解"}},[a._v("#")]),a._v(" 19.DOM事件有哪些阶段?谈谈对事件代理的理解")]),a._v(" "),s("h4",{attrs:{id:"分为三大阶段-捕捉阶段-目标阶段-冒泡阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分为三大阶段-捕捉阶段-目标阶段-冒泡阶段"}},[a._v("#")]),a._v(" 分为三大阶段： 捕捉阶段-目标阶段-冒泡阶段")]),a._v(" "),s("h4",{attrs:{id:"时间代理简单来说就是-事件不直接绑定到某元素上-而是绑定到该元素的父元素上-进行触发事件操作时-如click-再通过条件判断-执行事件触发后的语句。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间代理简单来说就是-事件不直接绑定到某元素上-而是绑定到该元素的父元素上-进行触发事件操作时-如click-再通过条件判断-执行事件触发后的语句。"}},[a._v("#")]),a._v(" 时间代理简单来说就是： 事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(如click)，再通过条件判断，执行事件触发后的语句。")]),a._v(" "),s("h4",{attrs:{id:"好处-1-使代码更简洁-2-节省内存开销。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#好处-1-使代码更简洁-2-节省内存开销。"}},[a._v("#")]),a._v(" 好处：1.使代码更简洁；2.节省内存开销。")]),a._v(" "),s("h3",{attrs:{id:"_20-介绍下promise-all"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_20-介绍下promise-all"}},[a._v("#")]),a._v(" 20.介绍下Promise.all")]),a._v(" "),s("h4",{attrs:{id:"promise-all-方法将多个promise实例包装成一个promise对象-接受一个数组作为参数-数组中不一定需要都是promise对象-但是一定具有iterator接口-如果不是的话-就会调用promise-resolve将其转化为promise对象之后在进行处理。-使用promise-all-生成的promise对象-p-的状态是由数组中的promise对象-p1-p2-p3-决定的。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-all-方法将多个promise实例包装成一个promise对象-接受一个数组作为参数-数组中不一定需要都是promise对象-但是一定具有iterator接口-如果不是的话-就会调用promise-resolve将其转化为promise对象之后在进行处理。-使用promise-all-生成的promise对象-p-的状态是由数组中的promise对象-p1-p2-p3-决定的。"}},[a._v("#")]),a._v(" Promise.all()方法将多个Promise实例包装成一个Promise对象，接受一个数组作为参数，数组中不一定需要都是Promise对象，但是一定具有Iterator接口，如果不是的话，就会调用Promise.resolve将其转化为Promise对象之后在进行处理。  使用Promise.all()生成的Promise对象(p)的状态是由数组中的Promise对象(p1,p2,p3)决定的。")]),a._v(" "),s("p",[a._v("1.如果所有的Promise对象(p1, p2, p3)都变成fullfilled状态的话，生成的Promise对象(p)也会变成fullfilled状态。  p1,p2,p3三个Promise对象产生的结果会组成一个数组传递给p的回调函数。\n2.如果p1,p2,p3中有一个Promise对象变为rejected状态的话,p也会变成rejected状态，第一个被rejected的对象返回值会传递给p的回调函数。"),s("br"),a._v("\nPromise.all()方法生成的Promise对象也会有一个catch方法来捕捉错误处理，但是如果数组中的Promise对象变成rejected状态时，且这个对象还定义了catch的方法，那么rejected的对象会执行自己的catch方法。  如果返回状态为fullfilled的Promise对象，Promise.all()生成的对象会接受这个Promise对象，不会返回rejected的状态。")]),a._v(" "),s("h3",{attrs:{id:"_21-讲讲async和await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21-讲讲async和await"}},[a._v("#")]),a._v(" 21.讲讲async和await")]),a._v(" "),s("h4",{attrs:{id:"主要考察宏任务和微任务-搭配promise-询问一些输出的顺序。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主要考察宏任务和微任务-搭配promise-询问一些输出的顺序。"}},[a._v("#")]),a._v(" 主要考察宏任务和微任务，搭配promise，询问一些输出的顺序。")]),a._v(" "),s("h4",{attrs:{id:"原理-async和await用了同步的方式去做异步-async定义的函数的返回值都是promise-await后面的函数会先执行一遍-然后就会跳出整个async函数来执行后面js栈的代码。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原理-async和await用了同步的方式去做异步-async定义的函数的返回值都是promise-await后面的函数会先执行一遍-然后就会跳出整个async函数来执行后面js栈的代码。"}},[a._v("#")]),a._v(" 原理：async和await用了同步的方式去做异步，async定义的函数的返回值都是promise，await后面的函数会先执行一遍，然后就会跳出整个async函数来执行后面js栈的代码。")]),a._v(" "),s("h3",{attrs:{id:"_22-讲讲js的垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_22-讲讲js的垃圾回收机制"}},[a._v("#")]),a._v(" 22.讲讲js的垃圾回收机制")]),a._v(" "),s("h4",{attrs:{id:"js在执行过程中会创建对象-那就意味着需要为这些对象在内存中分配空间-在这些对象失去使用的意义的时候-需要释放掉这些内容-保证内存能够提供给新的对象使用。对于对象内存的释放就是垃圾回收机制-也叫做gc。它会按照固定的时间间隔周期性的执行。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js在执行过程中会创建对象-那就意味着需要为这些对象在内存中分配空间-在这些对象失去使用的意义的时候-需要释放掉这些内容-保证内存能够提供给新的对象使用。对于对象内存的释放就是垃圾回收机制-也叫做gc。它会按照固定的时间间隔周期性的执行。"}},[a._v("#")]),a._v(" js在执行过程中会创建对象，那就意味着需要为这些对象在内存中分配空间，在这些对象失去使用的意义的时候，需要释放掉这些内容，保证内存能够提供给新的对象使用。对于对象内存的释放就是垃圾回收机制，也叫做gc。它会按照固定的时间间隔周期性的执行。")]),a._v(" "),s("h4",{attrs:{id:"最常见的垃圾回收方式是标记清除。工作原理是当变量进入环境时-将这个变量标记为-进入环境-。当变量离开环境时-则将其标记为-离开环境-。标记-离开环境-的就会被回收。主要流程是"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最常见的垃圾回收方式是标记清除。工作原理是当变量进入环境时-将这个变量标记为-进入环境-。当变量离开环境时-则将其标记为-离开环境-。标记-离开环境-的就会被回收。主要流程是"}},[a._v("#")]),a._v(" 最常见的垃圾回收方式是标记清除。工作原理是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就会被回收。主要流程是：")]),a._v(" "),s("p",[a._v("1.垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。"),s("br"),a._v("\n2.去掉环境中的变量以及被环境中的变量引用的变量的标记。"),s("br"),a._v("\n3.后面在被加上标记的是被视为准备删除的变量。"),s("br"),a._v("\n4.垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。")]),a._v(" "),s("h4",{attrs:{id:"还有一个方式是引用计数。它的原理是跟踪记录每个值被引用的次数。-主要工作流程是"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#还有一个方式是引用计数。它的原理是跟踪记录每个值被引用的次数。-主要工作流程是"}},[a._v("#")]),a._v(" 还有一个方式是引用计数。它的原理是跟踪记录每个值被引用的次数。 主要工作流程是：")]),a._v(" "),s("p",[a._v("1.声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。"),s("br"),a._v("\n2.每次当同一个值又被赋值给另一个值时，这个引用类型值的引用次数就会加1。"),s("br"),a._v("\n3.当引用次数变为0时，就说明没办法访问这个值了。"),s("br"),a._v("\n4.当垃圾收集器下一次运行时，就会释放引用次数为0的值所占的内存。"),s("br"),a._v("\n不过循环引用的时候就不会释放内存。循环引用就是对象A中包含另一个指向对象B的指针，B中也包含一个指向A的引用。  因为ie中的BOM、DOM的实现使用了COM，而COM对象使用的垃圾收集机制是引用计数策略。所以会存在循环引用的问题。"),s("br"),a._v("\n解决：手工断开js对象和DOM之间的链接。赋值为null。 ie9把DOM和BOM转换成真正的JS对象了，所以避免了这个问题。")]),a._v(" "),s("h4",{attrs:{id:"关于内存的泄露-常见的有4种-全局变量-未清除的定时器-闭包-以及dom的引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于内存的泄露-常见的有4种-全局变量-未清除的定时器-闭包-以及dom的引用"}},[a._v("#")]),a._v(" 关于内存的泄露，常见的有4种：全局变量，未清除的定时器，闭包，以及DOM的引用")]),a._v(" "),s("p",[a._v("1.全局变量，不使用变量声明的变量，会被挂载到window对象上，不会被回收。 可以使用严格模式解决。"),s("br"),a._v("\n2.忘记清除的定时器，定时器中有DOM的引用，即使DOM删除了，但是定时器还在，所以内存中还是有这个DOM。手动删除定时器和DOM可以解决。"),s("br"),a._v("\n3.闭包。闭包可以维持函数内局部变量，使其得不到释放。"),s("br"),a._v("\n4.没有清理的DOM元素的引用。  虽然别的地方删除了，但是对象中还存在对DOM的引用。 手动删除下。")]),a._v(" "),s("h4",{attrs:{id:"_23-对前端性能优化有什么了解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_23-对前端性能优化有什么了解"}},[a._v("#")]),a._v(" 23.对前端性能优化有什么了解?")]),a._v(" "),s("p",[a._v("1.减少请求数量"),s("br"),a._v("\n2.减小资源大小"),s("br"),a._v("\n3.优化网络连接"),s("br"),a._v("\n4.优化资源加载"),s("br"),a._v("\n5.减少重绘回流"),s("br"),a._v("\n6.性能更好的API"),s("br"),a._v("\n7.webpack优化")]),a._v(" "),s("h2",{attrs:{id:"vue"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[a._v("#")]),a._v(" Vue")]),a._v(" "),s("h3",{attrs:{id:"_1-vue双向数据绑定原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue双向数据绑定原理"}},[a._v("#")]),a._v(" 1.Vue双向数据绑定原理")]),a._v(" "),s("h4",{attrs:{id:"mvvm双向绑定-采用数据劫持结合发布者-订阅者模式的方法-通过object-defineproperty-来劫持各个属性的setter、getter-在数据变动时发布消息给订阅者-触发相应的监听回调。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mvvm双向绑定-采用数据劫持结合发布者-订阅者模式的方法-通过object-defineproperty-来劫持各个属性的setter、getter-在数据变动时发布消息给订阅者-触发相应的监听回调。"}},[a._v("#")]),a._v(" mvvm双向绑定,采用数据劫持结合发布者-订阅者模式的方法，通过Object.defineProperty()来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。")]),a._v(" "),s("h4",{attrs:{id:"这里面有几个要点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#这里面有几个要点"}},[a._v("#")]),a._v(" 这里面有几个要点：")]),a._v(" "),s("p",[a._v("1.实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者。"),s("br"),a._v("\n2.实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。"),s("br"),a._v("\n3.实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。"),s("br"),a._v("\n4.mvvm入口函数，整合以上三者。")]),a._v(" "),s("h4",{attrs:{id:"具体步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#具体步骤"}},[a._v("#")]),a._v(" 具体步骤：")]),a._v(" "),s("p",[a._v("1.需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter，这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。"),s("br"),a._v("\n2.compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。"),s("br"),a._v("\n3.Watch订阅者是Observer和Compile之间通信的桥梁，主要做的事情是：")]),a._v(" "),s("ul",[s("li",[a._v("在自身实例化时往属性订阅器(dep)里面添加自己")]),a._v(" "),s("li",[a._v("自身必须有一个update()方法")]),a._v(" "),s("li",[a._v("待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调"),s("br"),a._v("\n4.Mvvm作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新；视图交互变化(input)->数据model变更的双向绑定效果。")])]),a._v(" "),s("h3",{attrs:{id:"_2-描述下vue从初始化页面-修改数据-刷新页面ui的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-描述下vue从初始化页面-修改数据-刷新页面ui的过程"}},[a._v("#")]),a._v(" 2.描述下vue从初始化页面-修改数据-刷新页面UI的过程")]),a._v(" "),s("h4",{attrs:{id:"当vue进入初始化阶段是-一方面vue会遍历data中的属性-并用object-defineproperty将它转化成getter-setter的形式-实现数据劫持-暂时不谈3-0的proxy-另一方面-vue的指令编译器compiler对元素节点的各个指令进行解析-初始化视图-并订阅watcher来更新视图-此时watcher会将自己添加到消息订阅器dep中-此时初始化完毕。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当vue进入初始化阶段是-一方面vue会遍历data中的属性-并用object-defineproperty将它转化成getter-setter的形式-实现数据劫持-暂时不谈3-0的proxy-另一方面-vue的指令编译器compiler对元素节点的各个指令进行解析-初始化视图-并订阅watcher来更新视图-此时watcher会将自己添加到消息订阅器dep中-此时初始化完毕。"}},[a._v("#")]),a._v(" 当vue进入初始化阶段是，一方面vue会遍历data中的属性，并用Object.defineProperty将它转化成getter/setter的形式，实现数据劫持(暂时不谈3.0的Proxy)；另一方面，vue的指令编译器Compiler对元素节点的各个指令进行解析，初始化视图，并订阅Watcher来更新视图，此时Watcher会将自己添加到消息订阅器Dep中，此时初始化完毕。")]),a._v(" "),s("h4",{attrs:{id:"当数据发生变化时-触发observer中setter方法-立即调用dep-notify-dep这个数据开始遍历所有的订阅者-并调用其update方法-vue内部再通过diff算法-patch相应的更新完成对订阅者视图的改变。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当数据发生变化时-触发observer中setter方法-立即调用dep-notify-dep这个数据开始遍历所有的订阅者-并调用其update方法-vue内部再通过diff算法-patch相应的更新完成对订阅者视图的改变。"}},[a._v("#")]),a._v(" 当数据发生变化时，触发Observer中setter方法，立即调用Dep.notify()，Dep这个数据开始遍历所有的订阅者，并调用其update方法，vue内部再通过diff算法，patch相应的更新完成对订阅者视图的改变。")]),a._v(" "),s("h3",{attrs:{id:"_3-vue中key值的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue中key值的作用"}},[a._v("#")]),a._v(" 3.vue中key值的作用")]),a._v(" "),s("h4",{attrs:{id:"当vue-js用v-for正在更新已渲染过的元素列表时-它默认用-就地复用-策略。如果数据项的顺序被改变-vue将不会移动dom元素来匹配数据项的顺序-而是简单复用此处每个元素-并且确保它在特定索引下已被渲染过的每个元素。key的作用主要是为了高校的更新虚拟dom。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当vue-js用v-for正在更新已渲染过的元素列表时-它默认用-就地复用-策略。如果数据项的顺序被改变-vue将不会移动dom元素来匹配数据项的顺序-而是简单复用此处每个元素-并且确保它在特定索引下已被渲染过的每个元素。key的作用主要是为了高校的更新虚拟dom。"}},[a._v("#")]),a._v(" 当vue.js用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，vue将不会移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下已被渲染过的每个元素。key的作用主要是为了高校的更新虚拟DOM。")]),a._v(" "),s("h3",{attrs:{id:"_4-讲讲vue声明周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-讲讲vue声明周期"}},[a._v("#")]),a._v(" 4.讲讲vue声明周期")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("beforeCreate(初始化界面前)")])]),a._v(" "),s("li",[s("p",[a._v("created(初始化解面后)")])]),a._v(" "),s("li",[s("p",[a._v("beforeMount(渲染dom前)")])]),a._v(" "),s("li",[s("p",[a._v("mounted(渲染dom后)")])]),a._v(" "),s("li",[s("p",[a._v("beforeUpdate(更新数据前)")])]),a._v(" "),s("li",[s("p",[a._v("updated(更新数据后)")])]),a._v(" "),s("li",[s("p",[a._v("beforeDestroy(卸载组件前)")])]),a._v(" "),s("li",[s("p",[a._v("destroyed(卸载组件后)")])]),a._v(" "),s("li",[s("p",[a._v("beforeCreate(初始化界面前)  初始化了部分参数，如果有相同的参数，做了参数合并，执行beforeCreate")])]),a._v(" "),s("li",[s("p",[a._v("created(初始化解面后)   初始化了Inject、Provide、props、methods、data、computed和watch，执行created")])]),a._v(" "),s("li",[s("p",[a._v("beforeMount(渲染dom前)  检查是否存在el属性，存在的话进行渲染dom操作，执行beforeMount")])]),a._v(" "),s("li",[s("p",[a._v("mounted(渲染dom后)   实例化Watcher，渲染dom，执行mounted")])]),a._v(" "),s("li",[s("p",[a._v("beforeUpdate(更新数据前)  在渲染dom后，执行了mounted钩子后，在数据更新的时候，执行beforeUpdate")])]),a._v(" "),s("li",[s("p",[a._v("updated(更新数据后)  检查当前的watcher列表中，是否存在当前更新数据的watcher，如果存在就执行updated")])]),a._v(" "),s("li",[s("p",[a._v("beforeDestroy(卸载组件前)  检查是否已经被卸载，如果已经被卸载，就直接return出去，否则执行beforeDestroy")])]),a._v(" "),s("li",[s("p",[a._v("destroyed(卸载组件后)  把所有有关自己痕迹的地方，都给删除掉。")])])]),a._v(" "),s("h3",{attrs:{id:"_5-vue组件通信有哪些方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue组件通信有哪些方式"}},[a._v("#")]),a._v(" 5.vue组件通信有哪些方式？")]),a._v(" "),s("p",[a._v("1.props/$emit  适用于父子组件通信"),s("br"),a._v("\n2.$emit/$on (EnevtBus)  适用于父子、隔代、兄弟组件通信"),s("br"),a._v("\n这种方法通过一个空的Vue实例作为中央事件总线(事件中心)，用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。"),s("br"),a._v("\n3.vuex  适用于父子、隔代、兄弟组件通信"),s("br"),a._v("\nVuex是一个专为Vue.js应用程序开发的状态管理模式。每一个Vuex应用的核心就是store(仓库).store基本上就是一个容器，它包含着你的应用中大部分的状态。")]),a._v(" "),s("ul",[s("li",[a._v("Vuex的状态存储时响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应地得到高效更新。")]),a._v(" "),s("li",[a._v("改变store中的状态的唯一途径就是显式地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n4.$attrs/$listeners  适用于隔代组件通信")]),a._v(" "),s("li",[a._v('$attrs: 包含了父作用域中不被prop所识别(且获取)的特性绑定(class和style除外)。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定(class和style除外)，并且可以通过v-bind:"$attrs"传入内部组件。通常配合inheritAttrs选项一起使用。')]),a._v(" "),s("li",[a._v('$listeners: 包含了父作用域中的(不含.native修饰器的)v-on事件监听器。它可以通过v-on="$listeners"传入内部组件\n5.provide/inject  适用于隔代组件通信'),s("br"),a._v("\n祖先组件通过provider来提供变量，然后再子孙组件中通过inject来注入变量。provide/inject API主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。"),s("br"),a._v("\n6.$parent/$children与ref   适用于父子组件通信")]),a._v(" "),s("li",[a._v("ref: 如果在普通DOM元素上使用，引用指向的是DOM元素；如果在子组件上使用，引用指向组件实例")]),a._v(" "),s("li",[a._v("$paretn/$children: 访问父/子实例")])]),a._v(" "),s("h3",{attrs:{id:"_6-watch、methods和computed的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-watch、methods和computed的区别"}},[a._v("#")]),a._v(" 6.watch、methods和computed的区别")]),a._v(" "),s("h4",{attrs:{id:"watch为了监听某个响应数据的变化。computed是自动监听依赖值的变化-从而动态返回内容-主要目的是简化模板内的复杂运算。所以区别来源于用法-只是需要动态值-那就用computed-需要知道值的改变后执行业务逻辑-采用watch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#watch为了监听某个响应数据的变化。computed是自动监听依赖值的变化-从而动态返回内容-主要目的是简化模板内的复杂运算。所以区别来源于用法-只是需要动态值-那就用computed-需要知道值的改变后执行业务逻辑-采用watch"}},[a._v("#")]),a._v(" watch为了监听某个响应数据的变化。computed是自动监听依赖值的变化，从而动态返回内容，主要目的是简化模板内的复杂运算。所以区别来源于用法，只是需要动态值，那就用computed；需要知道值的改变后执行业务逻辑，采用watch")]),a._v(" "),s("h4",{attrs:{id:"methods是一个方法-它可以接受参数-而computed不能-computed是可以缓存的-methods不会。computed可以依赖其他computed-甚至是其他组件的data。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#methods是一个方法-它可以接受参数-而computed不能-computed是可以缓存的-methods不会。computed可以依赖其他computed-甚至是其他组件的data。"}},[a._v("#")]),a._v(" methods是一个方法，它可以接受参数，而computed不能，computed是可以缓存的，methods不会。computed可以依赖其他computed，甚至是其他组件的data。")]),a._v(" "),s("h3",{attrs:{id:"_7-组件中写name选项有什么作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-组件中写name选项有什么作用"}},[a._v("#")]),a._v(" 7.组件中写name选项有什么作用？")]),a._v(" "),s("p",[a._v("1.项目使用keep-alive时，可搭配组件name进行缓存过滤"),s("br"),a._v("\n2.DOM做递归组件时需要调用自身name"),s("br"),a._v("\n3.vue-devtools调试工具里显示的组件名称时由vue中组件name决定的。")]),a._v(" "),s("h3",{attrs:{id:"_8-vue-router有哪些钩子函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue-router有哪些钩子函数"}},[a._v("#")]),a._v(" 8.vue-router有哪些钩子函数？")]),a._v(" "),s("ul",[s("li",[a._v("全局前置守卫(router.beforeEach)")]),a._v(" "),s("li",[a._v("全局解析守卫(router.beforeResolve)")]),a._v(" "),s("li",[a._v("全局后置钩子(router.afterEach)")]),a._v(" "),s("li",[a._v("路由独享的守卫(beforeEnter)")]),a._v(" "),s("li",[a._v("组件内的守卫(beforeRouteEnter、 beforeRouteUpdate、beforeRouteLeave)")])]),a._v(" "),s("h3",{attrs:{id:"vuex有哪些属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex有哪些属性"}},[a._v("#")]),a._v(" vuex有哪些属性")]),a._v(" "),s("p",[a._v("1.State"),s("br"),a._v("\n2.Getter"),s("br"),a._v("\n3.Mutation"),s("br"),a._v("\n4.Action"),s("br"),a._v("\n5.Module")]),a._v(" "),s("h3",{attrs:{id:"说说你对spa单页面的理解-它的优缺点分别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说说你对spa单页面的理解-它的优缺点分别是什么"}},[a._v("#")]),a._v(" 说说你对SPA单页面的理解，它的优缺点分别是什么？")]),a._v(" "),s("h4",{attrs:{id:"spa仅在web页面初始化时加载相应的html、js、css。一旦页面加载完成-spa不会因为用户的操作而进行页面的重新加载或跳转-取而代之的是利用路由机制实现html内容的变换-ui于用户的交互-避免页面的重新加载。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#spa仅在web页面初始化时加载相应的html、js、css。一旦页面加载完成-spa不会因为用户的操作而进行页面的重新加载或跳转-取而代之的是利用路由机制实现html内容的变换-ui于用户的交互-避免页面的重新加载。"}},[a._v("#")]),a._v(" SPA仅在Web页面初始化时加载相应的html、js、css。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现html内容的变换，UI于用户的交互，避免页面的重新加载。")]),a._v(" "),s("p",[a._v("优点：")]),a._v(" "),s("ul",[s("li",[a._v("用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；")]),a._v(" "),s("li",[a._v("基于上面一点，SPA相对服务器压力小；")]),a._v(" "),s("li",[a._v("前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理。")])]),a._v(" "),s("p",[a._v("缺点：")]),a._v(" "),s("ul",[s("li",[a._v("初次加载耗时多，为实现单页Web应用功能及显示效果，需要在加载页面的时候将js、css统一加载，部分页面按需加载；")]),a._v(" "),s("li",[a._v("前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用游览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；")]),a._v(" "),s("li",[a._v("SEO难度较大：由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。")])]),a._v(" "),s("h3",{attrs:{id:"v-show和v-if的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-show和v-if的区别"}},[a._v("#")]),a._v(" v-show和v-if的区别")]),a._v(" "),s("h4",{attrs:{id:"v-if是真正的条件渲染-只有当条件第一次变为真时-才会开始渲染条件块。它会确保切换过程中条件块的事件监听器和子组件适当地被销毁和重建-它是惰性的。-而v-show是基于css的display属性进行切换。所以当我需要频繁的切换条件时-会选择使用v-show-而很少需要切换条件时-使用v-if。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-if是真正的条件渲染-只有当条件第一次变为真时-才会开始渲染条件块。它会确保切换过程中条件块的事件监听器和子组件适当地被销毁和重建-它是惰性的。-而v-show是基于css的display属性进行切换。所以当我需要频繁的切换条件时-会选择使用v-show-而很少需要切换条件时-使用v-if。"}},[a._v("#")]),a._v(" v-if是真正的条件渲染，只有当条件第一次变为真时，才会开始渲染条件块。它会确保切换过程中条件块的事件监听器和子组件适当地被销毁和重建，它是惰性的。  而v-show是基于css的display属性进行切换。所以当我需要频繁的切换条件时，会选择使用v-show，而很少需要切换条件时，使用v-if。")]),a._v(" "),s("h3",{attrs:{id:"class与style如何动态绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class与style如何动态绑定"}},[a._v("#")]),a._v(" class与style如何动态绑定？")]),a._v(" "),s("h4",{attrs:{id:"class可以通过对象语法和数组语法进行动态绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class可以通过对象语法和数组语法进行动态绑定"}},[a._v("#")]),a._v(" class可以通过对象语法和数组语法进行动态绑定：")]),a._v(" "),s("p",[a._v("对象语法")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("<div :class=\"{ active: isActive, 'text-danger': hasError}\"></div>\n\ndata: {\n  isActive: true,\n  hasError: false\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("p",[a._v("数组语法")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("<div :class2=\"[isActive2 ? activeClass: '', errorClass]\"></div>\n\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("h4",{attrs:{id:"style也可以通过对象语法和数组语法进行动态绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#style也可以通过对象语法和数组语法进行动态绑定"}},[a._v("#")]),a._v(" style也可以通过对象语法和数组语法进行动态绑定：")]),a._v(" "),s("p",[a._v("对象语法")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("<div :style=\"{color: activeColor, fontSize: fontSize + 'px'}\"></div>\n\ndata: {\n  activeColor: 'red',\n  fontSize: 30\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("p",[a._v("数组语法")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("<div :style=\"[styleColor, styleSize]\"></div>\ndata: {\n  styleColor: {\n    color: 'red'\n  },\n  styleSize: {\n    fontSize: '22px'\n  }\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("h3",{attrs:{id:"怎么样理解vue的单向数据流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么样理解vue的单向数据流"}},[a._v("#")]),a._v(" 怎么样理解vue的单向数据流")]),a._v(" "),s("h4",{attrs:{id:"所有的prop都使其父子prop之间形成了一个单向下行绑定-父级prop的更新会向下流动到子组件中-但是反过来则不行。这样是防止子组件意外改变父级组件的状态-从而导致应用的数据流向难以理解。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#所有的prop都使其父子prop之间形成了一个单向下行绑定-父级prop的更新会向下流动到子组件中-但是反过来则不行。这样是防止子组件意外改变父级组件的状态-从而导致应用的数据流向难以理解。"}},[a._v("#")]),a._v(" 所有的prop都使其父子prop之间形成了一个单向下行绑定：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样是防止子组件意外改变父级组件的状态，从而导致应用的数据流向难以理解。")]),a._v(" "),s("h4",{attrs:{id:"额外的-每次父级组件发生更新时-子组件中所有的prop都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变prop。如果你这样做了-vue会在游览器的控制台中发出警告。子组件想修改时-只能通过-emit派发一个自定义事件-父组件接收到后-由父组件修改。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#额外的-每次父级组件发生更新时-子组件中所有的prop都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变prop。如果你这样做了-vue会在游览器的控制台中发出警告。子组件想修改时-只能通过-emit派发一个自定义事件-父组件接收到后-由父组件修改。"}},[a._v("#")]),a._v(" 额外的，每次父级组件发生更新时，子组件中所有的prop都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变prop。如果你这样做了，vue会在游览器的控制台中发出警告。子组件想修改时，只能通过$emit派发一个自定义事件，父组件接收到后，由父组件修改。")]),a._v(" "),s("h4",{attrs:{id:"有两种常见的试图改变一个prop的情形"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有两种常见的试图改变一个prop的情形"}},[a._v("#")]),a._v(" 有两种常见的试图改变一个prop的情形：")]),a._v(" "),s("ul",[s("li",[a._v("这个prop用来传递一个初始值；这个子组件接下来希望将其作为一个本地的prop数据来使用。在这种情况下，最好定义一个本地的data属性并将这个prop用作其初始值：")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("props: ['initialCounter'],\ndata: function() {\n  return {\n    counter: this.initialCounter\n  }\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("ul",[s("li",[a._v("这个prop以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个prop的值来定义一个计算属性")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("props: ['size'],\ncomputed: {\n  normalizedSize: function() {\n    return this.size.trim().toLowerCase()\n  }\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("h3",{attrs:{id:"computed和watch的区别和运用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch的区别和运用场景"}},[a._v("#")]),a._v(" computed和watch的区别和运用场景？")]),a._v(" "),s("h4",{attrs:{id:"computed-是计算属性-依赖其他属性值-并且computed的值有缓存-只有它依赖的属性值发生改变-下一次获取computed的值时才会重新计算computed的值-watch-更多的是-观察-的作用-类似与某些数据的监听回调-每当监听的数据变化时-都会执行回调进行后续操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#computed-是计算属性-依赖其他属性值-并且computed的值有缓存-只有它依赖的属性值发生改变-下一次获取computed的值时才会重新计算computed的值-watch-更多的是-观察-的作用-类似与某些数据的监听回调-每当监听的数据变化时-都会执行回调进行后续操作"}},[a._v("#")]),a._v(" computed：是计算属性，依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值；   watch：更多的是[观察]的作用，类似与某些数据的监听回调，每当监听的数据变化时，都会执行回调进行后续操作；")]),a._v(" "),s("p",[a._v("运用场景：")]),a._v(" "),s("ul",[s("li",[a._v("当我们需要进行数值计算，并且依赖于其它数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时，都要重新计算；")]),a._v(" "),s("li",[a._v("当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作(访问一个API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")])]),a._v(" "),s("h3",{attrs:{id:"直接给一个数组项赋值-vue能检测到变化吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#直接给一个数组项赋值-vue能检测到变化吗"}},[a._v("#")]),a._v(" 直接给一个数组项赋值，Vue能检测到变化吗？")]),a._v(" "),s("h4",{attrs:{id:"由于javascript的限制-vue不能检测到以下数组的变动"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#由于javascript的限制-vue不能检测到以下数组的变动"}},[a._v("#")]),a._v(" 由于JavaScript的限制，Vue不能检测到以下数组的变动：")]),a._v(" "),s("ul",[s("li",[a._v("当你利用索引直接设置一个数组时，例如：vm.dataArray[indexOfItem] = newValue")]),a._v(" "),s("li",[a._v("当你改变数组的长度时：vm.dataArray.length = newLength")])]),a._v(" "),s("h4",{attrs:{id:"为了解决第一个问题-vue提供了以下操作方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为了解决第一个问题-vue提供了以下操作方法"}},[a._v("#")]),a._v(" 为了解决第一个问题，Vue提供了以下操作方法：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v(" Vue.set(vm.dataArray, indexOfItem, newValue)\n vm.$set(vm.dataArray, indexOfItem, newValue)\n vm.dataArray.splice(indexOfItem, 1, newValue)\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("h4",{attrs:{id:"为了解决第二个问题-vue提供了以下操作方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为了解决第二个问题-vue提供了以下操作方法"}},[a._v("#")]),a._v(" 为了解决第二个问题，Vue提供了以下操作方法：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("vm.dataArray.splice(newLength)\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("h3",{attrs:{id:"谈谈你对vue生命周期的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对vue生命周期的理解"}},[a._v("#")]),a._v(" 谈谈你对Vue生命周期的理解？")]),a._v(" "),s("p",[a._v("1.生命周期是什么？"),s("br"),a._v("\nVue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是Vue的生命周期。"),s("br"),a._v("\n2.各个声明周期的作用")]),a._v(" "),s("ul",[s("li",[a._v("beforeCreate: 组件实例被创建之初，组件的属性生效之前")]),a._v(" "),s("li",[a._v("created: 组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用")]),a._v(" "),s("li",[a._v("beforeMount: 在挂载开始之前被调用，相关的render函数首次被调用")]),a._v(" "),s("li",[a._v("mounted: el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子")]),a._v(" "),s("li",[a._v("beforeUpdate: 组件数据更新之前调用，发生在虚拟DOM打补丁之前")]),a._v(" "),s("li",[a._v("updated: 组件数据更新之后")]),a._v(" "),s("li",[a._v("activited: keep-alive专属，组件被激活时调用")]),a._v(" "),s("li",[a._v("deactivated: keep-alive专属，组件被销毁时调用")]),a._v(" "),s("li",[a._v("beforeDestory: 组件销毁前调用")]),a._v(" "),s("li",[a._v("destoryed: 组件销毁后调用")])]),a._v(" "),s("h3",{attrs:{id:"vue的父组件和子组件生命周期钩子函数执行顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue的父组件和子组件生命周期钩子函数执行顺序"}},[a._v("#")]),a._v(" Vue的父组件和子组件生命周期钩子函数执行顺序？")]),a._v(" "),s("h4",{attrs:{id:"vue的父组件和子组件生命周期钩子函数执行顺序可以归为类以下4部分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue的父组件和子组件生命周期钩子函数执行顺序可以归为类以下4部分"}},[a._v("#")]),a._v(" Vue的父组件和子组件生命周期钩子函数执行顺序可以归为类以下4部分：")]),a._v(" "),s("ul",[s("li",[a._v("加载渲染过程"),s("br"),a._v("\n父级beforeCreate -> 父级created -> 父级beforeMount -> 子级beforeCreate -> 子级created -> 子级beforeMount -> 子级mounted -> 父级mounted")]),a._v(" "),s("li",[a._v("子组件更新过程"),s("br"),a._v("\n父级beforeUpdate -> 子级beforeUpdate -> 子级updated -> 父级updated")]),a._v(" "),s("li",[a._v("父组件更新过程"),s("br"),a._v("\n父级beforeUpdate -> 父级updated")]),a._v(" "),s("li",[a._v("销毁过程"),s("br"),a._v("\n父级beforeDestroy -> 子级beforeDestroy -> 子级destroyed -> 父级destroyed")])]),a._v(" "),s("h3",{attrs:{id:"在哪个生命周期内调用异步请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在哪个生命周期内调用异步请求"}},[a._v("#")]),a._v(" 在哪个生命周期内调用异步请求？")]),a._v(" "),s("h4",{attrs:{id:"可以在钩子函数created、beforemount、mounted中进行调用-因为在这三个钩子函数中-data已经创建-可以将服务端返回的数据进行赋值。不过最好是在created钩子函数中调用异步请求-因为在created钩子函数中调用异步请求首先可以更快获取到服务端数据-减少页面loading时间-其次ssr不支持beforemount、mounted钩子函数-所以放在created中有助于一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可以在钩子函数created、beforemount、mounted中进行调用-因为在这三个钩子函数中-data已经创建-可以将服务端返回的数据进行赋值。不过最好是在created钩子函数中调用异步请求-因为在created钩子函数中调用异步请求首先可以更快获取到服务端数据-减少页面loading时间-其次ssr不支持beforemount、mounted钩子函数-所以放在created中有助于一致性"}},[a._v("#")]),a._v(" 可以在钩子函数created、beforeMount、mounted中进行调用，因为在这三个钩子函数中，data已经创建，可以将服务端返回的数据进行赋值。不过最好是在created钩子函数中调用异步请求，因为在created钩子函数中调用异步请求首先可以更快获取到服务端数据，减少页面loading时间，其次ssr不支持beforeMount、mounted钩子函数，所以放在created中有助于一致性；")]),a._v(" "),s("h3",{attrs:{id:"父组件可以监听到子组件的生命周期吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#父组件可以监听到子组件的生命周期吗"}},[a._v("#")]),a._v(" 父组件可以监听到子组件的生命周期吗？")]),a._v(" "),s("h4",{attrs:{id:"比如有父组件parent和子组件child-如果父组件监听到子组件挂载mounted就做一些逻辑处理-可以通过以下写法实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#比如有父组件parent和子组件child-如果父组件监听到子组件挂载mounted就做一些逻辑处理-可以通过以下写法实现"}},[a._v("#")]),a._v(" 比如有父组件Parent和子组件Child，如果父组件监听到子组件挂载mounted就做一些逻辑处理，可以通过以下写法实现：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('  // Parent.vue\n  <Child @mounted="doSomething" />\n\n  // Child.vue \n  mounted() {\n    this.$emit("mounted");\n  }\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("h4",{attrs:{id:"以上需要手动通过-emit触发父组件的事件-更简单的方式可以在父组件引用子组件时-通过-hook来监听即可-如下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#以上需要手动通过-emit触发父组件的事件-更简单的方式可以在父组件引用子组件时-通过-hook来监听即可-如下"}},[a._v("#")]),a._v(" 以上需要手动通过$emit触发父组件的事件，更简单的方式可以在父组件引用子组件时，通过@hook来监听即可，如下：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('  // Parent.vue\n  <Child @hook:mounted="doSomething" />\n  doSomething() {\n    console.log("父组件监听到mounted钩子函数..");\n  }\n\n  // Child.vue\n  mounted() {\n    console.log("子组件触发mounted钩子函数");\n  }\n  // 以上输出顺序为：\n  // 子组件触发mounted钩子函数  \n  // 父组件监听到mounted钩子函数  \n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br")])]),s("h4",{attrs:{id:"hook方法不仅仅可以监听mounted-其它的生命周期事件-例如-created-updated等都可以监听。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hook方法不仅仅可以监听mounted-其它的生命周期事件-例如-created-updated等都可以监听。"}},[a._v("#")]),a._v(" @hook方法不仅仅可以监听mounted，其它的生命周期事件，例如：created，updated等都可以监听。")]),a._v(" "),s("h3",{attrs:{id:"谈谈你对keep-alive的了解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对keep-alive的了解"}},[a._v("#")]),a._v(" 谈谈你对keep-alive的了解？")]),a._v(" "),s("h4",{attrs:{id:"keep-alive是vue内置的一个组件-可以使被包含的组件保留状态-避免重新渲染-其有以下特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive是vue内置的一个组件-可以使被包含的组件保留状态-避免重新渲染-其有以下特性"}},[a._v("#")]),a._v(" keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染，其有以下特性：")]),a._v(" "),s("ul",[s("li",[a._v("一般结合路由和动态组件一起使用，用于缓存组件；")]),a._v(" "),s("li",[a._v("提供include和exclude属性，两者都支持字符串或正则表达式，include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude的优先级比include高；")]),a._v(" "),s("li",[a._v("对应两个钩子函数activated和deactivated，当组件被激活时，触发钩子函数activated，当组件被移除时，触发钩子函数deactivated。")])]),a._v(" "),s("h3",{attrs:{id:"组件中data为什么是一个函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件中data为什么是一个函数"}},[a._v("#")]),a._v(" 组件中data为什么是一个函数？")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// data\ndata()  {\n  return {\n    message: \"子组件\",\n    childName: this.name\n  }\n}\n\n// new Vue\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: {App}\n})\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br")])]),s("h4",{attrs:{id:"因为组件是用来复用的-且js里对象是引用关系-如果组件中data是一个对象-那么这样作用雨没有隔离-子组件中的data属性值会互相影响-如果组件中data选项是一个函数-那么每个实例可以维护一份被返回对象的独立的拷贝-组件实例之间的data属性值不会互相影响-而new-vue的实例-是不会被复用的-因此不存在引用对象的问题。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#因为组件是用来复用的-且js里对象是引用关系-如果组件中data是一个对象-那么这样作用雨没有隔离-子组件中的data属性值会互相影响-如果组件中data选项是一个函数-那么每个实例可以维护一份被返回对象的独立的拷贝-组件实例之间的data属性值不会互相影响-而new-vue的实例-是不会被复用的-因此不存在引用对象的问题。"}},[a._v("#")]),a._v(" 因为组件是用来复用的，且js里对象是引用关系，如果组件中data是一个对象，那么这样作用雨没有隔离，子组件中的data属性值会互相影响，如果组件中data选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性值不会互相影响；而new Vue的实例，是不会被复用的，因此不存在引用对象的问题。")]),a._v(" "),s("h3",{attrs:{id:"讲讲vuex"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#讲讲vuex"}},[a._v("#")]),a._v(" 讲讲Vuex")]),a._v(" "),s("h4",{attrs:{id:"vuex是一个转为vue-js应用程序开发的状态管理模式。每一个vuex应用的核心就是store-仓库-。store基本上就是一个容器-它包含着你的应用中大部分的状态。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex是一个转为vue-js应用程序开发的状态管理模式。每一个vuex应用的核心就是store-仓库-。store基本上就是一个容器-它包含着你的应用中大部分的状态。"}},[a._v("#")]),a._v(" Vuex是一个转为Vue.js应用程序开发的状态管理模式。每一个Vuex应用的核心就是store(仓库)。store基本上就是一个容器，它包含着你的应用中大部分的状态。")]),a._v(" "),s("p",[a._v("1.Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应地得到高效更新。"),s("br"),a._v("\n2.改变store中的状态的唯一途径就是显式地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化。")]),a._v(" "),s("p",[a._v("主要包括以下几个模块：")]),a._v(" "),s("ul",[s("li",[a._v("State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。")]),a._v(" "),s("li",[a._v("Getter：允许组件从Store中获取数据，mapGetters辅助函数仅仅是将store中的getter隐射到局部计算属性。")]),a._v(" "),s("li",[a._v("Mutation：是唯一更改store中状态的方法，且必须是同步函数。")]),a._v(" "),s("li",[a._v("Action：用于提交mutation，而不是直接变更状态，可以包含任意异步操作。")]),a._v(" "),s("li",[a._v("Module：允许将单一的Store拆分为多个Store且同时保存在单一的状态树中。")])]),a._v(" "),s("h3",{attrs:{id:"使用过vue-ssr吗-说说ssr"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用过vue-ssr吗-说说ssr"}},[a._v("#")]),a._v(" 使用过Vue SSR吗?说说SSR")]),a._v(" "),s("h4",{attrs:{id:"vue-js是构建客户端应用程序的框架。默认情况下-可以在游览器中输出vue组件-进行生成dom和操作dom。然而-也可以将同一个组件渲染为服务端的html字符串-将它们直接发送到游览器-最后将这些静态标记-激活-为客户端上完全可以交互的应用程序。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-js是构建客户端应用程序的框架。默认情况下-可以在游览器中输出vue组件-进行生成dom和操作dom。然而-也可以将同一个组件渲染为服务端的html字符串-将它们直接发送到游览器-最后将这些静态标记-激活-为客户端上完全可以交互的应用程序。"}},[a._v("#")]),a._v(' Vue.js是构建客户端应用程序的框架。默认情况下，可以在游览器中输出Vue组件，进行生成DOM和操作DOM。然而，也可以将同一个组件渲染为服务端的HTML字符串，将它们直接发送到游览器，最后将这些静态标记"激活"为客户端上完全可以交互的应用程序。')]),a._v(" "),s("h4",{attrs:{id:"即-ssr大致的意思就是vue客户端将标签渲染成的整个html片段的工作在服务端完成-服务端形成的html片段直接返回给客户端这个过程就叫做服务端渲染。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#即-ssr大致的意思就是vue客户端将标签渲染成的整个html片段的工作在服务端完成-服务端形成的html片段直接返回给客户端这个过程就叫做服务端渲染。"}},[a._v("#")]),a._v(" 即：SSR大致的意思就是vue客户端将标签渲染成的整个html片段的工作在服务端完成，服务端形成的html片段直接返回给客户端这个过程就叫做服务端渲染。")]),a._v(" "),s("p",[a._v("服务端渲染SSR的优缺点如下：\n1.服务端渲染的优点：")]),a._v(" "),s("ul",[s("li",[a._v("更好的SEO：因为SPA页面的内容是通过Ajax获取，而搜索引擎爬取工具并不会等待Ajax异步完成后再抓取页面内容，所以再SPA中抓取不到页面通过Ajax获取到的内容；而SSR是直接由服务端返回已经渲染好的页面(数据已经包含在页面中)，所以搜引擎爬取工具可以抓取渲染好的页面；")]),a._v(" "),s("li",[a._v("更快的内容到达时间(首屏加载更快)：SPA会等待所有的Vue编译后的js文件都下载完成后，才开始进行页面的渲染，所以首屏渲染需要一定的时间；SSR直接由服务端渲染好页面直接返回显示，无需等待下载js文件再去渲染等，所以SSR有更快的内容到达时间；")])]),a._v(" "),s("p",[a._v("2.服务端渲染的缺点：")]),a._v(" "),s("ul",[s("li",[a._v("更多的开发条件限制：例如服务端渲染只支持beforCreate和created两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序SPA不同，服务端渲染应用程序，需要处于Node.js server运行环境；")]),a._v(" "),s("li",[a._v("更多的服务器负载：在Node.js中渲染完整的应用程序，显然会比仅仅提供静态文件的server更加大量占用CPU资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。")])]),a._v(" "),s("h3",{attrs:{id:"vue-roter路由模式有几种"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-roter路由模式有几种"}},[a._v("#")]),a._v(" vue-roter路由模式有几种？")]),a._v(" "),s("h4",{attrs:{id:"vue-router有3种路由模式-hash、history、abstract"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-router有3种路由模式-hash、history、abstract"}},[a._v("#")]),a._v(" vue-router有3种路由模式：hash、history、abstract")]),a._v(" "),s("ul",[s("li",[a._v("hash：使用URL hash值来做路由。支持所有游览器，包括不支持HTML5 History Api的游览器；")]),a._v(" "),s("li",[a._v("history： 依赖HTML5 History API和服务器配置。")]),a._v(" "),s("li",[a._v("abstract：支持所有JavaScript运行环境，如Node.js服务端。如果发现没有游览器的API，路由会自动强制进入这个模式。")])]),a._v(" "),s("h3",{attrs:{id:"能说下vue-router中常用的hash和history路由模式实现原理吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#能说下vue-router中常用的hash和history路由模式实现原理吗"}},[a._v("#")]),a._v(" 能说下vue-router中常用的hash和history路由模式实现原理吗？")]),a._v(" "),s("p",[a._v("1.hash模式的实现原理"),s("br"),a._v("\n早期的前端路由实现就是基于location.hash来实现的。其原理蛮简单，location.hash的值就是URL中#后面的内容。比如下面这个网站，它的location.hash的值为'#shuai'：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("https://www.yangkylin.cn#shuai\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("hash路由模式的实现主要是基于下面几个特性："),s("br"),a._v("\n* URL中hash值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash部分不会被发送；"),s("br"),a._v("\n* hash值的改变，都会在游览器的访问历史中增加一个记录。因此我们能通过游览器的回退、前进按钮控制hash的切换；"),s("br"),a._v("\n* 可以通过a标签，并设置href属性，当用户点击这个标签后，URL的hash值会发生改变；或者使用JavaScript来对location.hash进行赋值，改变URL的hash值；"),s("br"),a._v("\n* 我们可以使用hashchange事件来监听hash值得变化，从而对页面进行跳转。")]),a._v(" "),s("p",[a._v("2.history模式得实现原理"),s("br"),a._v("\nHTML5提供了History API来实现URL得变化。其中做最主要得API有以下两个： history.pushState()和history.replaceState()。这两个API可以在不进行刷新得情况下，操作游览器得历史记录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前得历史记录，如下所示：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("window.history.pushState(null,null,path);\nwindow.history.replaceState(null,null,path);\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("history路由模式的实现主要基于存在下面啊几个特性："),s("br"),a._v("\n* pushState和repalceState两个API来操作实现URL的变化；"),s("br"),a._v("\n* 我们可以使用popstate事件来监听url的变化，从而对页面进行跳转(渲染)；\n* history.pushState()或history.replaceState()不会触发popstate事件，这时我们需要手动触发页面跳转。")]),a._v(" "),s("h3",{attrs:{id:"什么是mvvm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是mvvm"}},[a._v("#")]),a._v(" 什么是MVVM？")]),a._v(" "),s("h4",{attrs:{id:"model-view-viewmodel是一个软件架构设计模式-一种简化用户界面的事件驱动编程方式。它的出现促进了前端开发与后端业务逻辑的分离-极大地提高了前端开发效率-mvvm的核心是viewmodel层-它就像是一个中转站-负责转换model中的数据对象来让数据变得更容易管理和使用-该层向上与视图进行双向数据绑定-向下与model层通过接口请求进行数据交互-起承上启下作用。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#model-view-viewmodel是一个软件架构设计模式-一种简化用户界面的事件驱动编程方式。它的出现促进了前端开发与后端业务逻辑的分离-极大地提高了前端开发效率-mvvm的核心是viewmodel层-它就像是一个中转站-负责转换model中的数据对象来让数据变得更容易管理和使用-该层向上与视图进行双向数据绑定-向下与model层通过接口请求进行数据交互-起承上启下作用。"}},[a._v("#")]),a._v(" Model-View-ViewModel是一个软件架构设计模式，一种简化用户界面的事件驱动编程方式。它的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM的核心是ViewModel层，它就像是一个中转站，负责转换Model中的数据对象来让数据变得更容易管理和使用，该层向上与视图进行双向数据绑定，向下与Model层通过接口请求进行数据交互，起承上启下作用。")]),a._v(" "),s("ul",[s("li",[a._v("View层：是视图层，也就是用户界面。主要由HTML和CSS来构建。")]),a._v(" "),s("li",[a._v("Model层：指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的api接口。")]),a._v(" "),s("li",[a._v("ViewModel层： 由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的Model数据进行转换处理，做二次封装，以生成符合View层使用预期的视图数据模型。需要注意的是ViewModel所封装出来的数据模型包括视图的状态和行为两部分，而Model层的数据模型是只包含状态的，比如页面的这一块显示什么，而页面加载进来时发生什么，点击某一块发生什么，滚动时发生什么这都属于视图行为(交互)，试图状态和行为都封装在了ViewModel里。这样的封装使得ViewModel可以完整地去描述View层。")])]),a._v(" "),s("p",[a._v("MVVM框架实现了双向绑定，这样ViewModel的内容会实时展现在View层，前端开发者再也不必低效又麻烦地通过操纵DOM去更新视图，MVVM框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护ViewModel，更新数据视图就会自动得到相应更新。这样View层展现的不是Model层的数据，而是ViewModel的数据，由ViewModel负责与Model层交互，这就完全解耦了View层和Model层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。")]),a._v(" "),s("h3",{attrs:{id:"vue是如何实现数据双向绑定的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue是如何实现数据双向绑定的"}},[a._v("#")]),a._v(" Vue是如何实现数据双向绑定的？")]),a._v(" "),s("h4",{attrs:{id:"vue数据双向绑定指的是-数据变化更新视图、试图变化更新数据。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue数据双向绑定指的是-数据变化更新视图、试图变化更新数据。"}},[a._v("#")]),a._v(" vue数据双向绑定指的是：数据变化更新视图、试图变化更新数据。")]),a._v(" "),s("h4",{attrs:{id:"即"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#即"}},[a._v("#")]),a._v(" 即：")]),a._v(" "),s("ul",[s("li",[a._v("输入框内容变化时，Data中的数据同步变化。View=>Data的变化。")]),a._v(" "),s("li",[a._v("Data中的数据变化时，文本节点的内容同步变化。Data=>View的变化。")])]),a._v(" "),s("h4",{attrs:{id:"其中-view变化更新data-可以通过事件监听的方式来实现-所以vue数据双向绑定的工作主要是如何根据data变化更新view。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其中-view变化更新data-可以通过事件监听的方式来实现-所以vue数据双向绑定的工作主要是如何根据data变化更新view。"}},[a._v("#")]),a._v(" 其中，View变化更新Data，可以通过事件监听的方式来实现，所以Vue数据双向绑定的工作主要是如何根据Data变化更新View。")]),a._v(" "),s("h4",{attrs:{id:"vue主要通过以下4个步骤来实现数据双向绑定的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue主要通过以下4个步骤来实现数据双向绑定的"}},[a._v("#")]),a._v(" Vue主要通过以下4个步骤来实现数据双向绑定的：")]),a._v(" "),s("p",[a._v("1.实现一个监听器Observer：对数据对象进行遍历，包括子属性对象的属性，利用Object.defineProperty()对属性上都加上setter和getter。这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。"),s("br"),a._v("\n2.实现一个解析器Compile：解析Vue模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。"),s("br"),a._v("\n3.实现一个订阅者Watcher：Watcher订阅者时Observer和Compile之间通信的桥梁，主要的任务是订阅Observer中的属性值变化的消息，当收到属性值变化的消息时，触发解析器Compile中对应的更新函数。"),s("br"),a._v("\n4.实现一个订阅器Dep：订阅器采用发布-订阅设计模式，用来收集订阅者Watcher，对监听器Observer和订阅者Watcher进行统一管理。")]),a._v(" "),s("h3",{attrs:{id:"虚拟dom的优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom的优缺点"}},[a._v("#")]),a._v(" 虚拟DOM的优缺点？")]),a._v(" "),s("p",[a._v("优点：")]),a._v(" "),s("ul",[s("li",[a._v("保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，它的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的，但是比起粗暴的DOM操作性能要好很多。因此框架的虚拟DOM至少可以保证你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；")]),a._v(" "),s("li",[a._v("无需手动操作DOM：我们不再需要手动操作DOM，只需要写好View-Model的代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；")]),a._v(" "),s("li",[a._v("跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便地跨平台操作，例如服务器渲染、weex开发等等。\n缺点：\n*无法进行极致优化：虽然虚拟DOM+合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化。")])]),a._v(" "),s("h3",{attrs:{id:"虚拟dom实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom实现原理"}},[a._v("#")]),a._v(" 虚拟DOM实现原理？")]),a._v(" "),s("h5",{attrs:{id:"主要包括以下3部分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主要包括以下3部分"}},[a._v("#")]),a._v(" 主要包括以下3部分：")]),a._v(" "),s("p",[a._v("1.用JavaScript对象模拟真实DOM树，对真实DOM进行抽象；"),s("br"),a._v("\n2.diff算法-比较两颗虚拟DOM树的差异；"),s("br"),a._v("\n3.pach算法-将两个虚拟DOM对象的差异应用到真正的DOM树。")]),a._v(" "),s("h3",{attrs:{id:"你对vue项目进行哪些优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你对vue项目进行哪些优化"}},[a._v("#")]),a._v(" 你对vue项目进行哪些优化？")]),a._v(" "),s("p",[a._v("1.代码层面的优化")]),a._v(" "),s("ul",[s("li",[a._v("v-if和v-show区分使用场景")]),a._v(" "),s("li",[a._v("computed和watch区分使用场景")]),a._v(" "),s("li",[a._v("v-for遍历必须为item添加key，且避免同时使用v-if")]),a._v(" "),s("li",[a._v("长列表性能优化")]),a._v(" "),s("li",[a._v("事件的销毁")]),a._v(" "),s("li",[a._v("图片资源懒加载")]),a._v(" "),s("li",[a._v("第三方插件的按需引入")]),a._v(" "),s("li",[a._v("优化无限列表性能")]),a._v(" "),s("li",[a._v("服务端渲染SSR or 预渲染")])]),a._v(" "),s("p",[a._v("2.Webpack层面的优化")]),a._v(" "),s("ul",[s("li",[a._v("Webpack对图片进行压缩")]),a._v(" "),s("li",[a._v("减少ES6转为ES5的冗余代码")]),a._v(" "),s("li",[a._v("提取公共代码")]),a._v(" "),s("li",[a._v("模板预编译")]),a._v(" "),s("li",[a._v("提取组件的CSS")]),a._v(" "),s("li",[a._v("优化SourceMap")]),a._v(" "),s("li",[a._v("构建结构输出分析")]),a._v(" "),s("li",[a._v("Vue项目的编译优化")])]),a._v(" "),s("p",[a._v("3.基础的Web技术的优化")]),a._v(" "),s("ul",[s("li",[a._v("开启gzip压缩")]),a._v(" "),s("li",[a._v("游览器缓存")]),a._v(" "),s("li",[a._v("CDN的使用")]),a._v(" "),s("li",[a._v("使用Chrome Performance查找性能瓶颈")])])])}),[],!1,null,null,null);t.default=r.exports}}]);