(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{598:function(e,s,a){"use strict";a.r(s);var r=a(3),n=Object(r.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("h3",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("h4",{attrs:{id:"本篇文章主要是重塑javascript的第六篇-在上一篇讲到了异步回调解决javascript单线程阻塞问题-这种方式没有问题-但是如果这种关系发生嵌套会造成-回调地狱-这一篇主要是针对这个问题-讲一讲每一种方法的使用。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本篇文章主要是重塑javascript的第六篇-在上一篇讲到了异步回调解决javascript单线程阻塞问题-这种方式没有问题-但是如果这种关系发生嵌套会造成-回调地狱-这一篇主要是针对这个问题-讲一讲每一种方法的使用。"}},[e._v("#")]),e._v(" 本篇文章主要是重塑JavaScript的第六篇，在上一篇讲到了异步回调解决JavaScript单线程阻塞问题，这种方式没有问题，但是如果这种关系发生嵌套会造成“回调地狱”，这一篇主要是针对这个问题，讲一讲每一种方法的使用。")])]),a("h4",{attrs:{id:"我们先看一个简单的回调地狱的代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我们先看一个简单的回调地狱的代码"}},[e._v("#")]),e._v(" 我们先看一个简单的回调地狱的代码：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function testFn(data,callback) {\n  setTimeout(function() {\n    callback(data);\n  }, 0);\n}\ntestFn('data1', function() {\n  testFn('data2', function() {\n    testFn('data3', function(data) {\n      console.log(data);\n    })\n  })\n});\n\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br")])]),a("h4",{attrs:{id:"这里写了一个使用settimeout模拟的简单异步回调嵌套调用-这个嵌套可能因为业务场景而导致更深-会导致代码横向括展-并且严重增加代码可读性、维护性和调式难度。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#这里写了一个使用settimeout模拟的简单异步回调嵌套调用-这个嵌套可能因为业务场景而导致更深-会导致代码横向括展-并且严重增加代码可读性、维护性和调式难度。"}},[e._v("#")]),e._v(" 这里写了一个使用setTimeout模拟的简单异步回调嵌套调用，这个嵌套可能因为业务场景而导致更深，会导致代码横向括展，并且严重增加代码可读性、维护性和调式难度。")]),e._v(" "),a("h4",{attrs:{id:"因此-出现了promise、generator、async、await-下面就这几种方法来进行介绍。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#因此-出现了promise、generator、async、await-下面就这几种方法来进行介绍。"}},[e._v("#")]),e._v(" 因此，出现了promise、generator、async、await，下面就这几种方法来进行介绍。")]),e._v(" "),a("h2",{attrs:{id:"promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),a("h4",{attrs:{id:"先来看看es6的promise-它的英文翻译过来是-承诺-朋友的承诺-情侣的承诺-都是一个带有期限的兑现-最终都面临着遵守承诺和违反承诺-promise的思路也是如此。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先来看看es6的promise-它的英文翻译过来是-承诺-朋友的承诺-情侣的承诺-都是一个带有期限的兑现-最终都面临着遵守承诺和违反承诺-promise的思路也是如此。"}},[e._v("#")]),e._v(" 先来看看ES6的Promise，它的英文翻译过来是“承诺”，朋友的承诺，情侣的承诺，都是一个带有期限的兑现，最终都面临着遵守承诺和违反承诺，Promise的思路也是如此。")]),e._v(" "),a("h4",{attrs:{id:"promise对象有两个特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise对象有两个特点"}},[e._v("#")]),e._v(" Promise对象有两个特点：")]),e._v(" "),a("p",[e._v("1.不受外界影响。Promise对象代表了异步回调的结果，承诺本身会有结果，有三种状态：pending(进行中)、fulfilled(以成功)和rejected(已失败)。只有异步操作的结果可以决定最终的状态，任何其他操作都无法改变这个状态。"),a("br"),e._v("\n2.一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：")]),e._v(" "),a("ul",[a("li",[e._v("从pending(进行中)到fulfilled(已成功)；")]),e._v(" "),a("li",[e._v("从pending(进行中)到rejected(已失败)。"),a("br"),e._v("\n只要这两种任意一种发生，状态就已经无法改变，要不分手要不结婚，并且再改变之后添加回调函数，也会立即得到这个结果。\nPromise不是什么新语法，只是为了优化“回调地狱”而出的一种写法。")])]),e._v(" "),a("h3",{attrs:{id:"基本使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本使用"}},[e._v("#")]),e._v(" 基本使用")]),e._v(" "),a("h4",{attrs:{id:"promise对象是一个构造函数-构造函数想到了什么-可以使用new来创建实例-生成promise实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise对象是一个构造函数-构造函数想到了什么-可以使用new来创建实例-生成promise实例"}},[e._v("#")]),e._v(" Promise对象是一个构造函数，构造函数想到了什么，可以使用new来创建实例，生成Promise实例；")]),e._v(" "),a("h4",{attrs:{id:"并且接受一个函数作为参数-该函数有两个参数-第一个是resolve-第二个是reject。它们是javascript引擎提供的两个函数。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并且接受一个函数作为参数-该函数有两个参数-第一个是resolve-第二个是reject。它们是javascript引擎提供的两个函数。"}},[e._v("#")]),e._v(" 并且接受一个函数作为参数，该函数有两个参数，第一个是resolve，第二个是reject。它们是JavaScript引擎提供的两个函数。")]),e._v(" "),a("blockquote",[a("p",[e._v("resolve:将Promise的状态从pending(进行中)到fulfilled(以成功)；在异步操作成功时调用，并把异步操作的结果作为参数传递进去。"),a("br"),e._v("\nreject: 将Promise的状态从pending(进行中)到rejected(已失败)；在异步操作失败的时候调用，把操作失败的报错作为参数传递进去。")])]),e._v(" "),a("h4",{attrs:{id:"如下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如下"}},[e._v("#")]),e._v(" 如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const promise = new Promise((resolve, reject) => {\n  if(/*异步执行是否成功*/) {\n    resolve(data);\n  } else {\n    reject(error);\n  }\n});\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("h4",{attrs:{id:"既然状态已更改-resolve-reject时引擎给我们提供的两个状态修改器-那我们该如何接受到这个状态呢-答案是通过链式的then和catch来处理的。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#既然状态已更改-resolve-reject时引擎给我们提供的两个状态修改器-那我们该如何接受到这个状态呢-答案是通过链式的then和catch来处理的。"}},[e._v("#")]),e._v(" 既然状态已更改，resolve，reject时引擎给我们提供的两个状态修改器，那我们该如何接受到这个状态呢？   答案是通过链式的then和catch来处理的。")]),e._v(" "),a("h3",{attrs:{id:"then、catch和finally"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#then、catch和finally"}},[e._v("#")]),e._v(" then、catch和finally")]),e._v(" "),a("h4",{attrs:{id:"then、catch和finally是promise-prototype原型上方法-所以可以用实例调用。先来看看then-举个栗子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#then、catch和finally是promise-prototype原型上方法-所以可以用实例调用。先来看看then-举个栗子"}},[e._v("#")]),e._v(" then、catch和finally是Promise.prototype原型上方法，所以可以用实例调用。先来看看then，举个栗子：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function timeout(ms) {\n  return new Promise((resolve, reject) {\n    setTimeout(resolve, ms, 'done');\n  })\n}\ntimeout(1000).then(value => console.log(value)); \n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("h4",{attrs:{id:"在上面的代码中-timeout方法将返回一个promise实例-而通过传递这个方法一个ms时间-将在这个时间后触发promise的resolve开关-改变状态为fulfilled-触发then-并且把-done-作为参数传递出去-最终输出-done-。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在上面的代码中-timeout方法将返回一个promise实例-而通过传递这个方法一个ms时间-将在这个时间后触发promise的resolve开关-改变状态为fulfilled-触发then-并且把-done-作为参数传递出去-最终输出-done-。"}},[e._v("#")]),e._v(" 在上面的代码中，timeout方法将返回一个Promise实例，而通过传递这个方法一个ms时间，将在这个时间后触发Promise的resolve开关，改变状态为fulfilled，触发then，并且把‘done’作为参数传递出去，最终输出‘done’。")]),e._v(" "),a("h4",{attrs:{id:"没错。这就是then的第一个用法-接受一个参数作为实例状态改为fulfilled时触发。那么海域偶第二个参数-就是当状态改变为rejected时触发。-下面有这样一段代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#没错。这就是then的第一个用法-接受一个参数作为实例状态改为fulfilled时触发。那么海域偶第二个参数-就是当状态改变为rejected时触发。-下面有这样一段代码"}},[e._v("#")]),e._v(" 没错。这就是then的第一个用法，接受一个参数作为实例状态改为fulfilled时触发。那么海域偶第二个参数，就是当状态改变为rejected时触发。 下面有这样一段代码：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function timeout(ms) {\n  return new Promise((resolve, reject) => {\n    setTime(() => {\n      const result = Math.random();\n      if(result > 0.5) {\n        resolve(result);\n      } else {\n        reject(result);\n      }\n    }, ms)\n  })\n}\n// 点击按钮会触发下面这段代码  \ntimeout(2000).then(value => {\n  console.log(`resolve: ${value}`);\n}, value => {\n  console.log(`reject: ${value}`);\n});\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br")])]),a("h4",{attrs:{id:"这段代码中-假设有个点击按钮-点击触发timeout-ms为2000-那就是在2秒钟后判断result随机值-0-0-1-0之间-是否大于0-5-如果大于则输出-resolve-result的随机值-如果小于-则是输出-reject-result的随机值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#这段代码中-假设有个点击按钮-点击触发timeout-ms为2000-那就是在2秒钟后判断result随机值-0-0-1-0之间-是否大于0-5-如果大于则输出-resolve-result的随机值-如果小于-则是输出-reject-result的随机值"}},[e._v("#")]),e._v(" 这段代码中，假设有个点击按钮，点击触发timeout，ms为2000，那就是在2秒钟后判断result随机值(0.0-1.0之间)是否大于0.5，如果大于则输出‘resolve： result的随机值 ’；如果小于，则是输出‘reject： result的随机值 ’；")]),e._v(" "),a("h4",{attrs:{id:"看起来then已经把事情做完了啊-那么catch是干啥用的。catch实际上就是相当于-then-null-rejection-或-then-undefined-rejection-也就是在状态改变为rejected时触发。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#看起来then已经把事情做完了啊-那么catch是干啥用的。catch实际上就是相当于-then-null-rejection-或-then-undefined-rejection-也就是在状态改变为rejected时触发。"}},[e._v("#")]),e._v(" 看起来then已经把事情做完了啊，那么catch是干啥用的。catch实际上就是相当于.then(null, rejection) 或 .then(undefined， rejection)，也就是在状态改变为rejected时触发。")]),e._v(" "),a("h4",{attrs:{id:"看个例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#看个例子"}},[e._v("#")]),e._v(" 看个例子：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("new Promise(function(resolve, reject) {\n  throw new Error('err');\n  resolve();\n})\n.then(() => {console.log('then');})\n.catch(() => {console.log('error');});\n// 输出'error'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("h4",{attrs:{id:"在resolve触发之前抛出了错误-直接会输出error-不会去触发then-因为状态已经rejected掉了。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在resolve触发之前抛出了错误-直接会输出error-不会去触发then-因为状态已经rejected掉了。"}},[e._v("#")]),e._v(" 在resolve触发之前抛出了错误，直接会输出error，不会去触发then，因为状态已经rejected掉了。")]),e._v(" "),a("h4",{attrs:{id:"catch还有一个特点是-它会捕捉then中的错误信息-还是见代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#catch还有一个特点是-它会捕捉then中的错误信息-还是见代码"}},[e._v("#")]),e._v(" catch还有一个特点是，它会捕捉then中的错误信息，还是见代码：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("new Promise(function(resolve, reject) {\n  resolve();\n}).then(() => {\n  console.log('then');\n  throw new Error('err');\n}).catch(() => {\n  console.log('error');\n});\n// 输出'then'\n// 输出'error'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])]),a("h4",{attrs:{id:"这段代码是在上面一段修改了下抛错位置-代码顺利触发resolve-进入then-输出then后抛错-被catch捕捉出error。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#这段代码是在上面一段修改了下抛错位置-代码顺利触发resolve-进入then-输出then后抛错-被catch捕捉出error。"}},[e._v("#")]),e._v(" 这段代码是在上面一段修改了下抛错位置，代码顺利触发resolve，进入then，输出then后抛错，被catch捕捉出error。")]),e._v(" "),a("h4",{attrs:{id:"三兄弟还剩下finally-finally该方法无论promise最终状态失败或者成功-都会执行-在then或者catch执行之后触发-给上面代码添加一段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三兄弟还剩下finally-finally该方法无论promise最终状态失败或者成功-都会执行-在then或者catch执行之后触发-给上面代码添加一段"}},[e._v("#")]),e._v(" 三兄弟还剩下finally，finally该方法无论Promise最终状态失败或者成功，都会执行，在then或者catch执行之后触发，给上面代码添加一段：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("new Promise(function(resolve, reject) {\n  resolve();\n}).then(() => {\n  console.log('then');\n  throw new Error('err');\n}).catch(() => {\n  console.log('error');\n}).finally(() => {\n  console.log('finally');\n})\n// 输出'then'\n// 输出'error'\n// 输出'finally'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br")])]),a("h3",{attrs:{id:"promise的链式调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise的链式调用"}},[e._v("#")]),e._v(" Promise的链式调用")]),e._v(" "),a("h4",{attrs:{id:"promise的原型上-目前主要就是这三个方法-用来触发状态变更后的回调和数据传递-并且最终会返回一个新的promise对象。那新的对象又可以调用原型上的then、catch方法-这样链式的调用-就可以代替之前的横向异步回调啦-resolve只会向第一个then里传递数据-后面的then里的函数只能通过前一个then的返回值来获取参数。下面改写一下片头的那段代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise的原型上-目前主要就是这三个方法-用来触发状态变更后的回调和数据传递-并且最终会返回一个新的promise对象。那新的对象又可以调用原型上的then、catch方法-这样链式的调用-就可以代替之前的横向异步回调啦-resolve只会向第一个then里传递数据-后面的then里的函数只能通过前一个then的返回值来获取参数。下面改写一下片头的那段代码"}},[e._v("#")]),e._v(" Promise的原型上，目前主要就是这三个方法，用来触发状态变更后的回调和数据传递，并且最终会返回一个新的Promise对象。那新的对象又可以调用原型上的then、catch方法，这样链式的调用，就可以代替之前的横向异步回调啦，resolve只会向第一个then里传递数据，后面的then里的函数只能通过前一个then的返回值来获取参数。下面改写一下片头的那段代码：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function testFn(data) {\n  return new Promise((resolve, reject) {\n    setTimeout(function() {\n      resolve(data);\n    }, 0);\n  })\n}\ntestFn('data1')\n.then(() => {\n  return testFn('data2')\n})\n.then(() => {\n  return testFn('data3')\n})\n.then((data) => {\n  console.log(data);\n});\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br")])]),a("h4",{attrs:{id:"可以发现promise对原本的代码从横向变成了纵向-除了代码逻辑相对清楚了一点-实际上还是很冗余的-一眼望去会是一堆的then。后面会介绍其他方法来进一步简化。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可以发现promise对原本的代码从横向变成了纵向-除了代码逻辑相对清楚了一点-实际上还是很冗余的-一眼望去会是一堆的then。后面会介绍其他方法来进一步简化。"}},[e._v("#")]),e._v(" 可以发现Promise对原本的代码从横向变成了纵向，除了代码逻辑相对清楚了一点，实际上还是很冗余的，一眼望去会是一堆的then。后面会介绍其他方法来进一步简化。")]),e._v(" "),a("h2",{attrs:{id:"promise的静态方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise的静态方法"}},[e._v("#")]),e._v(" Promise的静态方法")]),e._v(" "),a("h4",{attrs:{id:"promise原型上的方法介绍完-接下来介绍下promise构造函数上的静态方法。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise原型上的方法介绍完-接下来介绍下promise构造函数上的静态方法。"}},[e._v("#")]),e._v(" Promise原型上的方法介绍完，接下来介绍下Promise构造函数上的静态方法。")]),e._v(" "),a("h3",{attrs:{id:"promise-all"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[e._v("#")]),e._v(" Promise.all()")]),e._v(" "),a("h4",{attrs:{id:"promise-all将多个promise实例包装成一个promise实例。这个方法的规则是"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-all将多个promise实例包装成一个promise实例。这个方法的规则是"}},[e._v("#")]),e._v(" Promise.all将多个Promise实例包装成一个Promise实例。这个方法的规则是：")]),e._v(" "),a("p",[e._v("1.传入的是一个Promise实例组成的数组(或者是具有lterator接口的数据)，如果不是Promise实例，则会被转换；"),a("br"),e._v("\n2.数组所有异步执行完后，如果都fulfilled，则包装实例也为fulfilled；并且返回数组实例返回值构成的数组；"),a("br"),e._v("\n3.如果有一个rejected，则包装实例也为rejected；返回值为第一个被rejected的实例的返回值。")]),e._v(" "),a("h4",{attrs:{id:"举个栗子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#举个栗子"}},[e._v("#")]),e._v(" 举个栗子：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var p1 = new Promise((resolve) => {\n  resolve('success p1');\n});\nvar p2 = new Promise((resolve) => {\n  resolve('success p2');\n});\nvar p3 = new Promise((resolve, reject) => {\n  reject('fail p3');\n});\nPromise.all([p1, p2])\n.then((value) => {console.log('value:', value)})\n.catch((value) => {console.log('error:', error)});\n// 输出value：(2)[\"success p1\", \"success p2\" ]\nPromise.all([p1, p2, p3])\n.then((value) => {console.log('value:', value)})\n.catch((error) => {console.log('error:', error)})\n// 输出error： fail p3\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br")])]),a("h4",{attrs:{id:"这个方法在处理多个异步的时候可以派上用场-比如页面加载时需要进行多个ajax请求-然后才能渲染页面-那么这个时候可以利用这个方法-在所有异步执行完成之前显示loading样式。同时-它还有个优点是在成功后返回的数组数据与原先传递给方法的数组顺序是相同的-与执行完成的先后顺序无关。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#这个方法在处理多个异步的时候可以派上用场-比如页面加载时需要进行多个ajax请求-然后才能渲染页面-那么这个时候可以利用这个方法-在所有异步执行完成之前显示loading样式。同时-它还有个优点是在成功后返回的数组数据与原先传递给方法的数组顺序是相同的-与执行完成的先后顺序无关。"}},[e._v("#")]),e._v(" 这个方法在处理多个异步的时候可以派上用场，比如页面加载时需要进行多个ajax请求，然后才能渲染页面，那么这个时候可以利用这个方法，在所有异步执行完成之前显示loading样式。同时，它还有个优点"),a("strong",[e._v("是在成功后返回的数组数据与原先传递给方法的数组顺序是相同的，与执行完成的先后顺序无关。")])]),e._v(" "),a("h4",{attrs:{id:"需要注意如果触发reject本身有catch-那么就不会触发promise-all返回实例的catch了。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需要注意如果触发reject本身有catch-那么就不会触发promise-all返回实例的catch了。"}},[e._v("#")]),e._v(" 需要注意如果触发reject本身有catch，那么就不会触发Promise.all返回实例的catch了。")]),e._v(" "),a("h3",{attrs:{id:"promise-race"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-race"}},[e._v("#")]),e._v(" Promise.race()")]),e._v(" "),a("h4",{attrs:{id:"promise-race方法-race有竞赛的意思-在这个方法里也是这么个思想。它和promise。all一样将多个promise实例包装成一个promise实例。它的规则是"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-race方法-race有竞赛的意思-在这个方法里也是这么个思想。它和promise。all一样将多个promise实例包装成一个promise实例。它的规则是"}},[e._v("#")]),e._v(" Promise.race方法，race有竞赛的意思，在这个方法里也是这么个思想。它和Promise。all一样将多个Promise实例包装成一个Promise实例。它的规则是：")]),e._v(" "),a("p",[e._v("1.传入的是一个Promise实例组成的数组(或者是具有Iterator接口的数据)，如果不是Promise实例，则会被转换；"),a("br"),e._v("\n2.只要有一个实例fulfilled或者rejected就会触发包装实例的对应状态，并把返回值传递过去。"),a("br"),e._v("\n也就是不管整个Promise数组的结果是成功还是失败，谁快就返回谁。"),a("br"),e._v("\n举个栗子：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var p1 = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve('success p1');\n  }, 1000);\n});\nvar p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('fail p2');\n  }, 500);\n});\nPromise.race([p1, p2])\n.then((value) => {console.log('value:', value)})\n.catch((error) => {console.log('error:', error)});\n// 输出 error：fail p2\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br")])]),a("h4",{attrs:{id:"这个方法通常可以用来模拟fetch请求的timeout-如"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#这个方法通常可以用来模拟fetch请求的timeout-如"}},[e._v("#")]),e._v(" 这个方法通常可以用来模拟fetch请求的timeout，如：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Promise.race([\n  fetch('/xxx'),\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error('Timeout'))\n    }, 5000);\n  });\n])\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("h4",{attrs:{id:"由于fetch不像xmlhttprequest一样直接支持timeout-上面示例的意思是-如果在5秒内没有请求返回的话-就会被终止。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#由于fetch不像xmlhttprequest一样直接支持timeout-上面示例的意思是-如果在5秒内没有请求返回的话-就会被终止。"}},[e._v("#")]),e._v(" 由于fetch不像XMLHttpRequest一样直接支持timeout；上面示例的意思是，如果在5秒内没有请求返回的话，就会被终止。")]),e._v(" "),a("h3",{attrs:{id:"promise-allsettled"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-allsettled"}},[e._v("#")]),e._v(" Promise.allSettled()")]),e._v(" "),a("h4",{attrs:{id:"promise-allsettled方法-allsettled意思全部结算-它也是将一个多个promise实例包装成一个promise实例-等到所有的实例都有返回-不管是fulfilled还是rejected-都会触发包装实例的fulfilled-不会变成rejected-回调函数收到的参数是每个实例结果按照传参的顺序排列组成的数组。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-allsettled方法-allsettled意思全部结算-它也是将一个多个promise实例包装成一个promise实例-等到所有的实例都有返回-不管是fulfilled还是rejected-都会触发包装实例的fulfilled-不会变成rejected-回调函数收到的参数是每个实例结果按照传参的顺序排列组成的数组。"}},[e._v("#")]),e._v(" Promise.allSettled方法，allSettled意思全部结算，它也是将一个多个Promise实例包装成一个Promise实例，等到所有的实例都有返回，不管是fulfilled还是rejected，都会触发包装实例的fulfilled，不会变成rejected，回调函数收到的参数是每个实例结果按照传参的顺序排列组成的数组。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var p1 = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve('success p1');\n  }, 3000);\n});\nvar p2 = new Promise((resolve,reject) => {\n  setTimeout(() => {\n    reject('fail p2');\n  }, 500);\n});\nPromise.allSettled([p1, p2])\n.then((value) => {console.log('value:', value)})\n.catch((error) => {console.log('error:', error)})\n// 3秒后输出\n// value: [{status: \"fulfilled\", value: \"success p1\"}, reason: \"fail p2\", status: \"rejected\"]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br")])]),a("h4",{attrs:{id:"它的使用场景一般是多个异步-只关心结束-而不关心结果的时候-也是在页面加载的时候-多个ajax请求。这个方法可以在拿到无论成功或者失败的所有结果-可以针对失败的结果进行再次处理。all很难做到这两点。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#它的使用场景一般是多个异步-只关心结束-而不关心结果的时候-也是在页面加载的时候-多个ajax请求。这个方法可以在拿到无论成功或者失败的所有结果-可以针对失败的结果进行再次处理。all很难做到这两点。"}},[e._v("#")]),e._v(" 它的使用场景一般是多个异步，只关心结束，而不关心结果的时候，也是在页面加载的时候，多个ajax请求。这个方法可以在拿到无论成功或者失败的所有结果，可以针对失败的结果进行再次处理。all很难做到这两点。")]),e._v(" "),a("h3",{attrs:{id:"promise-any"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-any"}},[e._v("#")]),e._v(" Promise.any()")]),e._v(" "),a("h4",{attrs:{id:"paromise-any方法-也是将一个多个promise实例包装成一个promise实例。只要参数实例有一个变成fulfilled状态-包装实例就会变成fulfilled状态-如果所有参数实例都变成rejected状态-包装实例就会变成rejected状态。使用起来和promise-all刚好相反。-举个栗子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#paromise-any方法-也是将一个多个promise实例包装成一个promise实例。只要参数实例有一个变成fulfilled状态-包装实例就会变成fulfilled状态-如果所有参数实例都变成rejected状态-包装实例就会变成rejected状态。使用起来和promise-all刚好相反。-举个栗子"}},[e._v("#")]),e._v(" Paromise.any方法，也是将一个多个Promise实例包装成一个Promise实例。只要参数实例有一个变成Fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。使用起来和Promise.all刚好相反。 举个栗子：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('fail p1');\n  }, 1000);\n});\nvar p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('fail p2');\n  }, 500);\n});\nvar p3 = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve('success p3');\n  }, 800);\n});\nPromise.any([p1, p2])\n.then((value) => {console.log('value:', value)})\n.catch((error) => {console.log('error:', error)})\n// 输出error： ['fail p1', 'fail p2']\nPromise.any([p1, p2, p3])\n.then((value) => {console.log('value:', value)})\n.catch((error) => {console.log('error:', error)});\n// 输出 value: 'success p3'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br")])]),a("h3",{attrs:{id:"promise-resolve"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-resolve"}},[e._v("#")]),e._v(" Promise.resolve()")]),e._v(" "),a("h4",{attrs:{id:"上面都是批量处理promise实例的方法-其中都提到了一点-如果传递的参数不是一个promise实例数组-那么会把对应项转换为promise实例-使用的就是promise-resolve方法。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上面都是批量处理promise实例的方法-其中都提到了一点-如果传递的参数不是一个promise实例数组-那么会把对应项转换为promise实例-使用的就是promise-resolve方法。"}},[e._v("#")]),e._v(" 上面都是批量处理Promise实例的方法，其中都提到了一点，如果传递的参数不是一个Promise实例数组，那么会把对应项转换为Promise实例，使用的就是Promise.resolve方法。")]),e._v(" "),a("h4",{attrs:{id:"和javascript的其他类型转换一样-在转换为promise对象的时候也有不同的场景。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#和javascript的其他类型转换一样-在转换为promise对象的时候也有不同的场景。"}},[e._v("#")]),e._v(" 和JavaScript的其他类型转换一样，在转换为Promise对象的时候也有不同的场景。")]),e._v(" "),a("p",[e._v("1.参数就是一个Promise实例，直接返回该Promise实例。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  var p1 = new Promise((resolve) => {resolve('hi p1')});\n  var p2 = Promise.resolve(p1);\n  p2.then((value) => {console.log(value)});\n  // 输出 'hi p1' \n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("2.参数是一个具有then方法的对象，Promise.resolve方法会将这个对象转为Promise对象，并且立即执行它的then方法。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  var tthenable = {\n    then: function(resolve, reject) {\n      console.log('first');\n      resolve('end');\n    }\n  };\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("3.参数不是具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，并将该参数作为resolve函数参数传递。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  setTimeout(function() {\n    console.log('three');\n  }, 0);\n  Promise.resolve().then(function() {\n    console.log('two');\n  });\n  console.log('one');\n  // one \n  // two \n  // three\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])]),a("h3",{attrs:{id:"promise-reject"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-reject"}},[e._v("#")]),e._v(" Promise.reject()")]),e._v(" "),a("h4",{attrs:{id:"promise-reject方法很多地方和promise-resolve是相同的-这里主要说一下它的不同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-reject方法很多地方和promise-resolve是相同的-这里主要说一下它的不同点"}},[e._v("#")]),e._v(" Promise.reject方法很多地方和Promise.resolve是相同的，这里主要说一下它的不同点:")]),e._v(" "),a("p",[e._v("1.返回的是Promise实例的状态是rejected。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var p = Promise.reject('出错了');\np.then((value) => {\n  console.log('value:', value);\n}, (error) => {\n  console.log('error', error);\n});\n// error: 出错了\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("2.Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  var thenable = {\n    then(resolve, reject) {\n      reject('出错了');\n    }\n  };\n  Promise.reject(thenable)\n  .catch(e => {\n    console.log(e === thenable);\n  })\n  // true\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])]),a("h4",{attrs:{id:"promise的作用主要是优化异步的代码-但实际编写代码时-它似乎并不比回调的方式书写更简单-es2017有了async-await-这个语法改进跟promise配合-能够有效地改善代码结构。但是在讲async之前先看一下generator-因为async函数就是generator函数的语法糖。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise的作用主要是优化异步的代码-但实际编写代码时-它似乎并不比回调的方式书写更简单-es2017有了async-await-这个语法改进跟promise配合-能够有效地改善代码结构。但是在讲async之前先看一下generator-因为async函数就是generator函数的语法糖。"}},[e._v("#")]),e._v(" Promise的作用主要是优化异步的代码，但实际编写代码时，它似乎并不比回调的方式书写更简单，ES2017有了async/await，这个语法改进跟Promise配合，能够有效地改善代码结构。但是在讲async之前先看一下Generator，因为async函数就是Generator函数的语法糖。")]),e._v(" "),a("h2",{attrs:{id:"generator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[e._v("#")]),e._v(" Generator")]),e._v(" "),a("h4",{attrs:{id:"javascript对于generator是为了实现-协程-。那么我们先了解一下协程。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript对于generator是为了实现-协程-。那么我们先了解一下协程。"}},[e._v("#")]),e._v(" JavaScript对于Generator是为了实现“协程”。那么我们先了解一下协程。")]),e._v(" "),a("h3",{attrs:{id:"协程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协程"}},[e._v("#")]),e._v(" 协程")]),e._v(" "),a("h4",{attrs:{id:"协程-是一种很早就出现的概念-主要就是把函数执行暂停-然后递交执行权-之后可以在任意时间继续执行。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协程-是一种很早就出现的概念-主要就是把函数执行暂停-然后递交执行权-之后可以在任意时间继续执行。"}},[e._v("#")]),e._v(" “协程”是一种很早就出现的概念，主要就是把函数执行暂停，然后递交执行权，之后可以在任意时间继续执行。")]),e._v(" "),a("h4",{attrs:{id:"我们看一下javascript的通常运行方式-假如我们要运行一个函数a-那么就会在调用栈中添加函数a-而函数a里面又调用了函数b-b里面又调用了函数c-那么就要等待-c执行完知后返回-b执行完之后返回-最终a执行完返回。这种层级调用就是子程序-函数-的特点。一个线程就是执行一个子程序-一个入口-一次返回-调用顺序明确。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我们看一下javascript的通常运行方式-假如我们要运行一个函数a-那么就会在调用栈中添加函数a-而函数a里面又调用了函数b-b里面又调用了函数c-那么就要等待-c执行完知后返回-b执行完之后返回-最终a执行完返回。这种层级调用就是子程序-函数-的特点。一个线程就是执行一个子程序-一个入口-一次返回-调用顺序明确。"}},[e._v("#")]),e._v(" 我们看一下Javascript的通常运行方式，假如我们要运行一个函数a，那么就会在调用栈中添加函数a，而函数a里面又调用了函数b，b里面又调用了函数c，那么就要等待，c执行完知后返回，b执行完之后返回，最终a执行完返回。这种层级调用就是子程序(函数)的特点。一个线程就是执行一个子程序，一个入口，一次返回，调用顺序明确。")]),e._v(" "),a("h4",{attrs:{id:"而协程看上去也是子程序的层级调用-但是它的子程序是可以中断的-然后转而执行其它的子程序-在适当的时候回过头来继续执行中断的子程序。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#而协程看上去也是子程序的层级调用-但是它的子程序是可以中断的-然后转而执行其它的子程序-在适当的时候回过头来继续执行中断的子程序。"}},[e._v("#")]),e._v(" 而协程看上去也是子程序的层级调用，但是它的子程序是可以中断的，然后转而执行其它的子程序，在适当的时候回过头来继续执行中断的子程序。")]),e._v(" "),a("h4",{attrs:{id:"比如下列代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#比如下列代码"}},[e._v("#")]),e._v(" 比如下列代码：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  function* gen1() {\n    yield console.log(1);\n    yield console.log(2);\n    yield console.log(3);\n  }\n  function* gen2() {\n    yield console.log('a');\n    yield console.log('b');\n    yield console.log('c');\n  }\n  var g1 = gen1();\n  var g2 = gen2();\n  g1.next();\n  g2.next();\n  g1.next();\n  g2.next();\n  g1.next();\n  g2.next();\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br")])]),a("h4",{attrs:{id:"利用这种思路的写法-最终得到的结果并不是想象中的-1-2-3-a-b-c-而是-1-a-2-b-3-c。单从代码中并没有看到他们俩个有互相调用。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#利用这种思路的写法-最终得到的结果并不是想象中的-1-2-3-a-b-c-而是-1-a-2-b-3-c。单从代码中并没有看到他们俩个有互相调用。"}},[e._v("#")]),e._v(" 利用这种思路的写法，最终得到的结果并不是想象中的 1 -> 2 -> 3 -> a -> b -> c，而是 1 -> a -> 2 -> b -> 3 -> c。单从代码中并没有看到他们俩个有互相调用。")]),e._v(" "),a("h4",{attrs:{id:"协程和多线程不一样。协程始终还是在一个线程上执行-把暂停的子程序的栈保存-来回切换子程序执行。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协程和多线程不一样。协程始终还是在一个线程上执行-把暂停的子程序的栈保存-来回切换子程序执行。"}},[e._v("#")]),e._v(" 协程和多线程不一样。协程始终还是在一个线程上执行，把暂停的子程序的栈保存，来回切换子程序执行。")]),e._v(" "),a("h3",{attrs:{id:"generator的基本使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generator的基本使用"}},[e._v("#")]),e._v(" Generator的基本使用")]),e._v(" "),a("h4",{attrs:{id:"javascript的generator实际上就是一个循环状态机-它看起来是一个函数-但是和函数又不一样。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript的generator实际上就是一个循环状态机-它看起来是一个函数-但是和函数又不一样。"}},[e._v("#")]),e._v(" JavaScript的Generator实际上就是一个循环状态机，它看起来是一个函数，但是和函数又不一样。")]),e._v(" "),a("h4",{attrs:{id:"我们来看一下它的基本使用示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我们来看一下它的基本使用示例"}},[e._v("#")]),e._v(" 我们来看一下它的基本使用示例：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function* say() {\n  yield 'Hi';\n  yield 'buddy';\n  return 'Bye';\n}\nvar g = say();\ng.next(); // {value: 'Hi', done: false}\ng.next(); // {value: 'buddy', done: false}\ng.next(); // {value: 'Bye', done: true}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("h4",{attrs:{id:"通常通过在function关键字后紧跟-表示这是一个generator函数来区别普通函数-最终生成一个遍历器对象-返回指向内部状态的指针对象。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通常通过在function关键字后紧跟-表示这是一个generator函数来区别普通函数-最终生成一个遍历器对象-返回指向内部状态的指针对象。"}},[e._v("#")]),e._v(" 通常通过在function关键字后紧跟*表示这是一个Generator函数来区别普通函数，最终生成一个遍历器对象，返回指向内部状态的指针对象。")]),e._v(" "),a("h4",{attrs:{id:"通过yield关键字来定义状态-返回的指针对象利用next方法来切换状态。直到return语句为止。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过yield关键字来定义状态-返回的指针对象利用next方法来切换状态。直到return语句为止。"}},[e._v("#")]),e._v(" 通过yield关键字来定义状态，返回的指针对象利用next方法来切换状态。直到return语句为止。")]),e._v(" "),a("h4",{attrs:{id:"也就是说-我们通过generator函数得到一个遍历器对象的指针后-每执行一次它的next方法-便会把对应的指针移动到下一个yield表达式。如果没有遇到下一个yield表达式或者遇到return语句-则将最终返回值-没有return语句默认undefined-作为当前next调用结果的value值。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#也就是说-我们通过generator函数得到一个遍历器对象的指针后-每执行一次它的next方法-便会把对应的指针移动到下一个yield表达式。如果没有遇到下一个yield表达式或者遇到return语句-则将最终返回值-没有return语句默认undefined-作为当前next调用结果的value值。"}},[e._v("#")]),e._v(" 也就是说，我们通过Generator函数得到一个遍历器对象的指针后，每执行一次它的next方法，便会把对应的指针移动到下一个yield表达式。如果没有遇到下一个yield表达式或者遇到return语句，则将最终返回值(没有return语句默认undefined)作为当前next调用结果的value值。")]),e._v(" "),a("h3",{attrs:{id:"generator解决异步的应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generator解决异步的应用"}},[e._v("#")]),e._v(" Generator解决异步的应用")]),e._v(" "),a("h4",{attrs:{id:"本篇主要还是讲的generator函数在解决异步回调上的应用-详细的generator功能可以通过文档去了解。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本篇主要还是讲的generator函数在解决异步回调上的应用-详细的generator功能可以通过文档去了解。"}},[e._v("#")]),e._v(" 本篇主要还是讲的Generator函数在解决异步回调上的应用，详细的Generator功能可以通过文档去了解。")]),e._v(" "),a("h4",{attrs:{id:"实际上generator函数解决异步回调仍然是异步函数的思维-但是是在模拟同步的写法。按照上面的用法-假设我们在每一个yield关键字后写入的是一个异步操作-然后再每一个异步操作结束后在执行下一步-那么就可以完成看起来同步的书写了。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实际上generator函数解决异步回调仍然是异步函数的思维-但是是在模拟同步的写法。按照上面的用法-假设我们在每一个yield关键字后写入的是一个异步操作-然后再每一个异步操作结束后在执行下一步-那么就可以完成看起来同步的书写了。"}},[e._v("#")]),e._v(" 实际上Generator函数解决异步回调仍然是异步函数的思维，但是是在模拟同步的写法。按照上面的用法，假设我们在每一个yield关键字后写入的是一个异步操作，然后再每一个异步操作结束后在执行下一步，那么就可以完成看起来同步的书写了。")]),e._v(" "),a("h4",{attrs:{id:"利用generator-promise写一个简单的场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#利用generator-promise写一个简单的场景"}},[e._v("#")]),e._v(" 利用Generator + Promise写一个简单的场景：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function* gen() {\n  var first = yield new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('hi');\n    }, 3000);\n  });\n  console.log(first);\n  var second = yield new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('buddy');\n    }, 2000)\n  });\n  console.log(second);\n  console.log('bye');\n}\nvar g = gen();\ng.next().value.then((value) => {\n  return g.next(value).value;\n})\n.then((value) => {\n  g.next(value).value;\n});\n// 3s后输出'hi'\n// 再过2s输出 'buddy' 'bye'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br")])]),a("h4",{attrs:{id:"解释一下这段代码的内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释一下这段代码的内容"}},[e._v("#")]),e._v(" 解释一下这段代码的内容：")]),e._v(" "),a("p",[e._v("1.创建了一个gen的Generator函数，然后调用函数获取到遍历指针g；"),a("br"),e._v("\n2.调用next，执行第一个异步Promise，拿到其返回的对象；3s后触发then方法，获取到异步传递的数据'hi';"),a("br"),e._v("\n3.通过调用下一个next方法把值传递给first，并执行输出first后执行下一个Promise；拿到其返回的Promise对象；"),a("br"),e._v("\n4.2s后触发then回调，获取到异步传递的数据'buddy';"),a("br"),e._v("\n5.通过调用下一个next把'buddy'赋值给second，然后输出second；然后接着输出最后的'bey'")]),e._v(" "),a("h4",{attrs:{id:"看起来也太太太太太大太太复杂了-感觉一点都不好用的亚子啊。还需要自己调用-手动赋值。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#看起来也太太太太太大太太复杂了-感觉一点都不好用的亚子啊。还需要自己调用-手动赋值。"}},[e._v("#")]),e._v(" 看起来也太太太太太大太太复杂了，感觉一点都不好用的亚子啊。还需要自己调用，手动赋值。")]),e._v(" "),a("h4",{attrs:{id:"不过呢-generator函数实际上创建的是一个遍历器-也就是可以遍历执行每一个yield-那么我们可以对这个形式进行封装-比较出名的一个是co。核心代码其实很少-加上一些转换方法-代码也没有200行。我们来研究一下它的核心代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不过呢-generator函数实际上创建的是一个遍历器-也就是可以遍历执行每一个yield-那么我们可以对这个形式进行封装-比较出名的一个是co。核心代码其实很少-加上一些转换方法-代码也没有200行。我们来研究一下它的核心代码"}},[e._v("#")]),e._v(" 不过呢 ，Generator函数实际上创建的是一个遍历器，也就是可以遍历执行每一个yield，那么我们可以对这个形式进行封装，比较出名的一个是co。核心代码其实很少，加上一些转换方法，代码也没有200行。我们来研究一下它的核心代码：")]),e._v(" "),a("h4",{attrs:{id:"首先-co保存上下文-获取调用时传递的其他参数-最终参数是传递给gen-最终会返回一个promise对象-使结果可以调用then方法。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#首先-co保存上下文-获取调用时传递的其他参数-最终参数是传递给gen-最终会返回一个promise对象-使结果可以调用then方法。"}},[e._v("#")]),e._v(" 首先，co保存上下文，获取调用时传递的其他参数，最终参数是传递给gen，最终会返回一个Promise对象，使结果可以调用then方法。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function co(gen) {\n  var ctx = this;\n  var args = slice.call(arguments, 1);\n  return new Promise(function(resolve, reject){\n\n  });\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("h4",{attrs:{id:"在返回的对象中-先检查gen参数是否是一个generator函数-如果是就把参数传递进去执行-得到一个指针对象。如果不是就直接返回-并将promise对象的状态改为resolved。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在返回的对象中-先检查gen参数是否是一个generator函数-如果是就把参数传递进去执行-得到一个指针对象。如果不是就直接返回-并将promise对象的状态改为resolved。"}},[e._v("#")]),e._v(" 在返回的对象中，先检查gen参数是否是一个Generator函数，如果是就把参数传递进去执行，得到一个指针对象。如果不是就直接返回，并将Promise对象的状态改为resolved。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function co(gen) {\n  var ctx = this;\n  var args = slice.call(arguments, 1);\n  return new Promise(function(resolve, reject){\n    if(typeof gen === 'function'){ gen = gen.apply(ctx, args); }\n    if(!gen || gen.next !== 'function'){ return resolve(gen); }\n  });\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("h4",{attrs:{id:"讲内部指针的next方法包装成onfulfilled方法-用于捕捉抛出的错误"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#讲内部指针的next方法包装成onfulfilled方法-用于捕捉抛出的错误"}},[e._v("#")]),e._v(" 讲内部指针的next方法包装成onFulfilled方法，用于捕捉抛出的错误")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function co(gen) {\n  var ctx = this;\n  var args = slice.call(arguments, 1);\n  return new Promise(function(resolve, reject){\n    if(typeof gen === 'function'){ gen = gen.apply(ctx, args); }\n    if(!gen || gen.next !== 'function'){ return resolve(gen); }\n    onFulfilled();\n    function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch(e) {\n        return reject(e);\n      }\n      next(ret);\n      return null;\n    }\n  });\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br")])]),a("h4",{attrs:{id:"最后是onfulfilled中的next函数-如果符合条件会通过onfulfilled递归调用自身。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最后是onfulfilled中的next函数-如果符合条件会通过onfulfilled递归调用自身。"}},[e._v("#")]),e._v(" 最后是onFulfilled中的next函数，如果符合条件会通过onFulfilled递归调用自身。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" function next(ret) {\n   if(ret.done) return resolve(ret.value);\n   var value = toPromise.call(ctx, ret.value);\n   if( value && isPromise(value)) return value.then(onFulfilled, onRejected);\n    return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: \"' + String(ret.value) + '\"'));\n }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("h4",{attrs:{id:"解释一下这个next函数做的事情"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释一下这个next函数做的事情"}},[e._v("#")]),e._v(" 解释一下这个next函数做的事情：")]),e._v(" "),a("p",[e._v("1.判断这个Generator函数是否执行结束，是则直接返回并传递最终的返回值；"),a("br"),e._v("\n2.保证本次执行拿到的结果是一个Promise，toPromise方法封装了一些类型转换Promise的方法；"),a("br"),e._v("\n3.在结果为Promise的前提下，调用then方法，并在成功的情况下再次回调onFulfilled;"),a("br"),e._v("\n4.在结果不符合类型的情况下，讲Promise对象的状态改为rejected，终止行为。")]),e._v(" "),a("h4",{attrs:{id:"co的核心代码就是这些了-可以去它的github看一看源码。-封装好了co-那么之前我们hi-bye的例子可以这么写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#co的核心代码就是这些了-可以去它的github看一看源码。-封装好了co-那么之前我们hi-bye的例子可以这么写"}},[e._v("#")]),e._v(" co的核心代码就是这些了，可以去它的gitHub看一看源码。  封装好了co，那么之前我们hi bye的例子可以这么写：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function* gen() {\n  var first = yield new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('hi');\n    }, 3000)\n  });\n  console.log(first);\n  var second = yield new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('buddy');\n    }, 2000)\n  });\n  console.log(second);\n  console.log('bye');\n}\nco(gen);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("h4",{attrs:{id:"没错-写法还是之前那个同步类似同步写法的generator函数了-调用直接通过co调用就好了-里面的传值和自动遍历已经处理好了"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#没错-写法还是之前那个同步类似同步写法的generator函数了-调用直接通过co调用就好了-里面的传值和自动遍历已经处理好了"}},[e._v("#")]),e._v(" 没错，写法还是之前那个同步类似同步写法的Generator函数了，调用直接通过co调用就好了，里面的传值和自动遍历已经处理好了！")]),e._v(" "),a("h4",{attrs:{id:"还有一个小问题-上面的执行是把所有的异步都拿来做同步效果了-那么如果想实现类似于promise-allsettled这样的效果呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#还有一个小问题-上面的执行是把所有的异步都拿来做同步效果了-那么如果想实现类似于promise-allsettled这样的效果呢"}},[e._v("#")]),e._v(" 还有一个小问题，上面的执行是把所有的异步都拿来做同步效果了，那么如果想实现类似于Promise.allSettled这样的效果呢？")]),e._v(" "),a("h4",{attrs:{id:"co也支持-只要把并发的操作都放在数组或者对象里面-跟在yield语句后面就可以了。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#co也支持-只要把并发的操作都放在数组或者对象里面-跟在yield语句后面就可以了。"}},[e._v("#")]),e._v(" co也支持，只要把并发的操作都放在数组或者对象里面，跟在yield语句后面就可以了。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("co(function* () {\n  var res = yield [\n    Promise.resolve(1),\n    Promise.resolve(2)\n  ];\n  console.log(res);\n}).catch(err => console.log(err));\n// [1, 2]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("h4",{attrs:{id:"generator处理异步的能力是有的-但它的出现并不是完全为了做这件事的-违背了设计者的初衷-于是。又有了另一个语法糖补丁async-await来修正这个问题。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generator处理异步的能力是有的-但它的出现并不是完全为了做这件事的-违背了设计者的初衷-于是。又有了另一个语法糖补丁async-await来修正这个问题。"}},[e._v("#")]),e._v(" Generator处理异步的能力是有的，但它的出现并不是完全为了做这件事的，违背了设计者的初衷，于是。又有了另一个语法糖补丁async/await来修正这个问题。")]),e._v(" "),a("h3",{attrs:{id:"async-await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[e._v("#")]),e._v(" async/await")]),e._v(" "),a("h4",{attrs:{id:"async函数是什么-一句话-它就是generator函数的语法糖-理解了generator就能更快理解async。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async函数是什么-一句话-它就是generator函数的语法糖-理解了generator就能更快理解async。"}},[e._v("#")]),e._v(" async函数是什么？一句话，它就是Generator函数的语法糖，理解了Generator就能更快理解async。")]),e._v(" "),a("h4",{attrs:{id:"比如上面hi-buddy的例子-用async的语法写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#比如上面hi-buddy的例子-用async的语法写"}},[e._v("#")]),e._v(" 比如上面hi buddy的例子，用async的语法写：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("async function say() {\n  var first = await new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('hi');\n    }, 3000);\n  });\n  console.log(first);\n  var second = await new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('buddy');\n    }, 2000);\n  });\n  console.log(second);\n  console.log('bye');\n}\nsay();\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("h4",{attrs:{id:"看起来和generator是不是没什么区别-但是我们没有自己去写一个自动执行其co了呀。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#看起来和generator是不是没什么区别-但是我们没有自己去写一个自动执行其co了呀。"}},[e._v("#")]),e._v(" 看起来和Generator是不是没什么区别，但是我们没有自己去写一个自动执行其co了呀。")]),e._v(" "),a("h3",{attrs:{id:"async和generator的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async和generator的区别"}},[e._v("#")]),e._v(" async和Generator的区别")]),e._v(" "),a("h4",{attrs:{id:"上面把一个generator的代码使用async来进行编写-看起来整体代码风格没有太大变化-那么我们来看一下它们的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上面把一个generator的代码使用async来进行编写-看起来整体代码风格没有太大变化-那么我们来看一下它们的区别"}},[e._v("#")]),e._v(" 上面把一个Generator的代码使用async来进行编写，看起来整体代码风格没有太大变化，那么我们来看一下它们的区别：")]),e._v(" "),a("p",[e._v("1.内置执行器。"),a("br"),e._v("\n很明显的，我们调用的时候不再使用自己编写的执行器(co)去调用了，async是Generator语法糖，那我们很容易就想到，是内置了这个执行器，不需要各门各派的自我处理了。这也和一个标准函数更像了。"),a("br"),e._v("\n2.更好的语义。"),a("br"),e._v("\nasync替代了*，await替代了yield，一看就能理解哪里是异步，哪里需要等待的代码。"),a("br"),e._v("\n3.更广的适用性。"),a("br"),e._v("\nco模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值(数值、字符串、和布尔值，但这时会自动转成立即resolved的Promise对象)。"),a("br"),e._v("\n4.返回值是Promise"),a("br"),e._v("\nasync函数的返回值是一个Promise，也就是可以用then进行下一步了，毕竟是一个异步函数嘛。")]),e._v(" "),a("h4",{attrs:{id:"主要的区别就是这些了-下面再继续讲一下大概的使用方式。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要的区别就是这些了-下面再继续讲一下大概的使用方式。"}},[e._v("#")]),e._v(" 主要的区别就是这些了，下面再继续讲一下大概的使用方式。")]),e._v(" "),a("h3",{attrs:{id:"async的应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async的应用"}},[e._v("#")]),e._v(" async的应用")]),e._v(" "),a("h4",{attrs:{id:"async函数就可以看作是把多个异步也就是promise包装成一个promise-使用的方式再熟悉了generator基本上没有什么难度。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async函数就可以看作是把多个异步也就是promise包装成一个promise-使用的方式再熟悉了generator基本上没有什么难度。"}},[e._v("#")]),e._v(" async函数就可以看作是把多个异步也就是Promise包装成一个Promise，使用的方式再熟悉了Generator基本上没有什么难度。")]),e._v(" "),a("h4",{attrs:{id:"主要是它的错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要是它的错误处理"}},[e._v("#")]),e._v(" 主要是它的错误处理")]),e._v(" "),a("h3",{attrs:{id:"包装promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#包装promise"}},[e._v("#")]),e._v(" 包装Promise")]),e._v(" "),a("h4",{attrs:{id:"async函数的返回值是一个promise-也就是说说它有then和catch-那么对于什么时候触发呢-毕竟它可没有引擎提供的resolve和reject开关。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async函数的返回值是一个promise-也就是说说它有then和catch-那么对于什么时候触发呢-毕竟它可没有引擎提供的resolve和reject开关。"}},[e._v("#")]),e._v(" async函数的返回值是一个Promise，也就是说说它有then和catch，那么对于什么时候触发呢？毕竟它可没有引擎提供的resolve和reject开关。")]),e._v(" "),a("h4",{attrs:{id:"async这个关键字的意思其实是-后面这个函数中可能会有异步操作。而这些异步操作都是用await来标识-因此async函数返回的promise对象-必须等待await后面的promise执行完才会发生状态变化-除非遇到return语句或者抛出错误。return语句返回的值-会成为then方法回调函数的参数。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async这个关键字的意思其实是-后面这个函数中可能会有异步操作。而这些异步操作都是用await来标识-因此async函数返回的promise对象-必须等待await后面的promise执行完才会发生状态变化-除非遇到return语句或者抛出错误。return语句返回的值-会成为then方法回调函数的参数。"}},[e._v("#")]),e._v(" async这个关键字的意思其实是，后面这个函数中可能会有异步操作。而这些异步操作都是用await来标识，因此async函数返回的Promise对象，必须等待await后面的Promise执行完才会发生状态变化，除非遇到return语句或者抛出错误。return语句返回的值，会成为then方法回调函数的参数。")]),e._v(" "),a("h4",{attrs:{id:"我们可以想象下-实际上整体是一个promise-然后里面是一个generator-等到generator的遍历器执行到done为true的时候-我们触发resolve即可。如果抛出错误-触发reject。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我们可以想象下-实际上整体是一个promise-然后里面是一个generator-等到generator的遍历器执行到done为true的时候-我们触发resolve即可。如果抛出错误-触发reject。"}},[e._v("#")]),e._v(" 我们可以想象下，实际上整体是一个Promise，然后里面是一个Generator，等到Generator的遍历器执行到done为true的时候，我们触发resolve即可。如果抛出错误，触发reject。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("async function asyncFn() {\n  console.log(1);\n  await Promise.resolve(console.log(2));\n  console.log(3);\n  await new Promise((resolve) => {\n    console.log(4);\n    resolve();\n  });\n  console.log(5);\n  return 6;\n}\nasyncFn()\n.then((value) => {\n  console.log(value);\n});\n// 1 -> 2 -> 3 -> 4 -> 5 -> 6\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("h3",{attrs:{id:"错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[e._v("#")]),e._v(" 错误处理")]),e._v(" "),a("h4",{attrs:{id:"如果await后面的promise中抛出错误-那么就会把async返回的promise状态设置为rejected-导致函数内容执行立即结束。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果await后面的promise中抛出错误-那么就会把async返回的promise状态设置为rejected-导致函数内容执行立即结束。"}},[e._v("#")]),e._v(" 如果await后面的Promise中抛出错误，那么就会把async返回的Promise状态设置为rejected，导致函数内容执行立即结束。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("async function asyncFn() {\n  await new Promise(() => {\n    throw new Error('出错了');\n  });\n  console.log('Hi,')\n  return 'buddy!';\n}\n\nasyncFn()\n.then(v => console.log('value:', v))\n.catch(e => console.log('err:', e));\n// err: 出错了\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])]),a("h4",{attrs:{id:"处理这个问题的方式是-通过-try-catch把异步的部分包裹起来"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理这个问题的方式是-通过-try-catch把异步的部分包裹起来"}},[e._v("#")]),e._v(" 处理这个问题的方式是，通过 try ... catch把异步的部分包裹起来：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("async function asyncFn() {\n  try {\n    await new Promise(() => {\n      throw new Error('出错了');\n    });\n  } catch (e) {}\n  console.log('Hi,')\n  return 'buddy!';\n}\n\nasyncFn()\n.then(v => console.log('value:', v))\n.catch(e => console.log('err:', e));\n// Hi,\n// value: buddy!\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br")])]),a("h4",{attrs:{id:"同样的-最后如果想在async函数内并发执行多个异步-那么我们可以使用promise-all等方法进行处理即可。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同样的-最后如果想在async函数内并发执行多个异步-那么我们可以使用promise-all等方法进行处理即可。"}},[e._v("#")]),e._v(" 同样的，最后如果想在async函数内并发执行多个异步，那么我们可以使用Promise.all等方法进行处理即可。")]),e._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("h4",{attrs:{id:"本篇内容主要讲了比较主要的异步回调解决方法-promise的篇幅占用比较多-因为不管是generator还是async-await-promise都是基础。整个解决方法仍然是用异步的思想写着模拟同步的代码-只是不断在代码表达上有更多的优化。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本篇内容主要讲了比较主要的异步回调解决方法-promise的篇幅占用比较多-因为不管是generator还是async-await-promise都是基础。整个解决方法仍然是用异步的思想写着模拟同步的代码-只是不断在代码表达上有更多的优化。"}},[e._v("#")]),e._v(" 本篇内容主要讲了比较主要的异步回调解决方法，Promise的篇幅占用比较多，因为不管是Generator还是async/await，Promise都是基础。整个解决方法仍然是用异步的思想写着模拟同步的代码，只是不断在代码表达上有更多的优化。")]),e._v(" "),a("h4",{attrs:{id:"promise是一种规约-他将回调调用和错误处理规范化-generator和async-await都是语法糖-里面的各种功能都可以原生实现-而异步驱动还是得靠回调-也就是得用promise进行包装。深刻的理解-回调异步-才是重点。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise是一种规约-他将回调调用和错误处理规范化-generator和async-await都是语法糖-里面的各种功能都可以原生实现-而异步驱动还是得靠回调-也就是得用promise进行包装。深刻的理解-回调异步-才是重点。"}},[e._v("#")]),e._v(" Promise是一种规约，他将回调调用和错误处理规范化，Generator和async/await都是语法糖，里面的各种功能都可以原生实现，而异步驱动还是得靠回调，也就是得用Promise进行包装。深刻的理解“回调异步”才是重点。")])])}),[],!1,null,null,null);s.default=n.exports}}]);