(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{579:function(e,t,r){"use strict";r.r(t);var a=r(3),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"title"}),r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),r("h4",{attrs:{id:"先讲一下render-tree-然后介绍回流-会触发回流的操作、属性、方法。-然后讲重绘-接着讲性能影响和游览器对其优化。-清空队列。-最后怎么避免"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#先讲一下render-tree-然后介绍回流-会触发回流的操作、属性、方法。-然后讲重绘-接着讲性能影响和游览器对其优化。-清空队列。-最后怎么避免"}},[e._v("#")]),e._v(" 先讲一下Render Tree ，然后介绍回流，会触发回流的操作、属性、方法。 然后讲重绘，接着讲性能影响和游览器对其优化。 清空队列。 最后怎么避免")])]),r("h2",{attrs:{id:"render-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#render-tree"}},[e._v("#")]),e._v(" Render Tree")]),e._v(" "),r("h4",{attrs:{id:"首先介绍render-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#首先介绍render-tree"}},[e._v("#")]),e._v(" 首先介绍Render Tree：")]),e._v(" "),r("p",[e._v("1.游览器会把html解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了RenderTree"),r("br"),e._v("\n2.有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。"),r("br"),e._v("\n3.由于游览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍同等元素的时间，这也是为什么要避免使用table布局的原因之一。")]),e._v(" "),r("h2",{attrs:{id:"回流-reflow"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow"}},[e._v("#")]),e._v(" 回流(Reflow)")]),e._v(" "),r("h4",{attrs:{id:"当render-tree中有元素的尺寸、结构、或某些属性发生改变时-游览器重新渲染的过程称为回流。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#当render-tree中有元素的尺寸、结构、或某些属性发生改变时-游览器重新渲染的过程称为回流。"}},[e._v("#")]),e._v(" 当Render Tree中有元素的尺寸、结构、或某些属性发生改变时，游览器重新渲染的过程称为回流。")]),e._v(" "),r("h4",{attrs:{id:"会导致回流的操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#会导致回流的操作"}},[e._v("#")]),e._v(" 会导致回流的操作：")]),e._v(" "),r("ul",[r("li",[e._v("页面首次渲染")]),e._v(" "),r("li",[e._v("游览器窗口大小发生改变")]),e._v(" "),r("li",[e._v("元素尺寸或位置发生改变")]),e._v(" "),r("li",[e._v("元素内容变化")]),e._v(" "),r("li",[e._v("元素字体大小变化")]),e._v(" "),r("li",[e._v("添加或者删除可见的DOM元素")]),e._v(" "),r("li",[e._v("激活CSS伪类（例如 ：hover）")]),e._v(" "),r("li",[e._v("查询某些属性或调用某些方法")])]),e._v(" "),r("h4",{attrs:{id:"一些常用且会导致回流的属性和方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一些常用且会导致回流的属性和方法"}},[e._v("#")]),e._v(" 一些常用且会导致回流的属性和方法：")]),e._v(" "),r("ul",[r("li",[e._v("clientWidth、clientHeight、clientTop、clientLeft")]),e._v(" "),r("li",[e._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),e._v(" "),r("li",[e._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),e._v(" "),r("li",[e._v("scrollIntoView()、scrollIntoViewIfNeeded()")]),e._v(" "),r("li",[e._v("getComputedStyle()")]),e._v(" "),r("li",[e._v("scrollTo()")])]),e._v(" "),r("h2",{attrs:{id:"重绘-repaint"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint"}},[e._v("#")]),e._v(" 重绘(Repaint)")]),e._v(" "),r("h4",{attrs:{id:"当render-tree中元素样式的改变并不影响它在文档流中的位置时-例如-color、background-color、visibility等-游览器会将新样式赋予给元素并重新绘制它-这个过程为重绘。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#当render-tree中元素样式的改变并不影响它在文档流中的位置时-例如-color、background-color、visibility等-游览器会将新样式赋予给元素并重新绘制它-这个过程为重绘。"}},[e._v("#")]),e._v(" 当Render Tree中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），游览器会将新样式赋予给元素并重新绘制它，这个过程为重绘。")]),e._v(" "),r("p",[e._v("需要注意的是：回流必将引起重绘，重绘不一定会引起回流。")]),e._v(" "),r("h2",{attrs:{id:"性能影响"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#性能影响"}},[e._v("#")]),e._v(" 性能影响")]),e._v(" "),r("h4",{attrs:{id:"回流比重绘的代价要更高。-有时仅仅回流一个元素-它的父元素以及任何跟随它的元素也会产生回流。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回流比重绘的代价要更高。-有时仅仅回流一个元素-它的父元素以及任何跟随它的元素也会产生回流。"}},[e._v("#")]),e._v(" 回流比重绘的代价要更高。  有时仅仅回流一个元素，它的父元素以及任何跟随它的元素也会产生回流。")]),e._v(" "),r("h2",{attrs:{id:"游览器会对频繁的回流或重绘操作进行优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#游览器会对频繁的回流或重绘操作进行优化"}},[e._v("#")]),e._v(" 游览器会对频繁的回流或重绘操作进行优化")]),e._v(" "),r("h4",{attrs:{id:"游览器会维护一个队列-把所有引起回流和重绘的操作放入队列中-如果队列中的任务数量或者时间间隔达到一个阈值的时候-游览器就会将任务队列清空-进行一次批处理-这样可以把多次回流和重绘变成一次。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#游览器会维护一个队列-把所有引起回流和重绘的操作放入队列中-如果队列中的任务数量或者时间间隔达到一个阈值的时候-游览器就会将任务队列清空-进行一次批处理-这样可以把多次回流和重绘变成一次。"}},[e._v("#")]),e._v(" 游览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的时候，游览器就会将任务队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。")]),e._v(" "),r("p",[e._v("当你访问以下属性或方法时，游览器会立刻清空队列")]),e._v(" "),r("ul",[r("li",[e._v("clientWidth、clientHeight、clientTop、clientLeft")]),e._v(" "),r("li",[e._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),e._v(" "),r("li",[e._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),e._v(" "),r("li",[e._v("width、height")]),e._v(" "),r("li",[e._v("getComputedStyle()")])]),e._v(" "),r("h2",{attrs:{id:"如何避免"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何避免"}},[e._v("#")]),e._v(" 如何避免")]),e._v(" "),r("p",[e._v("CSS")]),e._v(" "),r("ul",[r("li",[e._v("将动画效果应用到position属性为absolute或fixed的元素上")]),e._v(" "),r("li",[e._v("避免使用table布局")]),e._v(" "),r("li",[e._v("尽可能在DOM树的最末端改变class")]),e._v(" "),r("li",[e._v("避免设置多层内联样式")]),e._v(" "),r("li",[e._v("避免使用CSS表达式 - calc")])]),e._v(" "),r("p",[e._v("JavaScript")]),e._v(" "),r("ul",[r("li",[e._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")]),e._v(" "),r("li",[e._v("避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性")]),e._v(" "),r("li",[e._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")]),e._v(" "),r("li",[e._v("也可以先为元素设置display：none ，操作结束后再把它显示出来，因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。")]),e._v(" "),r("li",[e._v("避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);