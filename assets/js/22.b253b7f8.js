(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{527:function(s,n,a){s.exports=a.p+"assets/img/EC-base-call.74f20e00.png"},573:function(s,n,a){"use strict";a.r(n);var t=a(3),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,t=s._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"}),t("h3",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),t("h4",{attrs:{id:"本篇文章主要是重塑javascript的第七篇-从javascript运行时的基础上-细化知识点-研究代码执行时所做的事情及包含的信息-去理解我们平时讲的一些作用域、闭包、this等概念。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本篇文章主要是重塑javascript的第七篇-从javascript运行时的基础上-细化知识点-研究代码执行时所做的事情及包含的信息-去理解我们平时讲的一些作用域、闭包、this等概念。"}},[s._v("#")]),s._v(" 本篇文章主要是重塑JavaScript的第七篇，从JavaScript运行时的基础上，细化知识点，研究代码执行时所做的事情及包含的信息，去理解我们平时讲的一些作用域、闭包、this等概念。")])]),t("h4",{attrs:{id:"前面关于事件循环的那一篇-讲的是javascript任务在运行机制-而一个任务中可能包含很多的函数调用等其他内容-再形成一个个任务-接下来-先入手的内容叫做-执行上下文-。-通过-执行上下文-理解代码执行时包含的信息。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前面关于事件循环的那一篇-讲的是javascript任务在运行机制-而一个任务中可能包含很多的函数调用等其他内容-再形成一个个任务-接下来-先入手的内容叫做-执行上下文-。-通过-执行上下文-理解代码执行时包含的信息。"}},[s._v("#")]),s._v(" 前面关于事件循环的那一篇，讲的是JavaScript任务在运行机制，而一个任务中可能包含很多的函数调用等其他内容，再形成一个个任务，接下来，先入手的内容叫做“执行上下文”。 通过“执行上下文”理解代码执行时包含的信息。")]),s._v(" "),t("h2",{attrs:{id:"执行上下文-execution-context"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文-execution-context"}},[s._v("#")]),s._v(" 执行上下文(Execution Context)")]),s._v(" "),t("h4",{attrs:{id:"在ecmasscript中的代码被分为三种类型-global、function和eval。每一种代码的执行都依赖自己的上下文。它们的特点是"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在ecmasscript中的代码被分为三种类型-global、function和eval。每一种代码的执行都依赖自己的上下文。它们的特点是"}},[s._v("#")]),s._v(" 在ECMASscript中的代码被分为三种类型，global、function和eval。每一种代码的执行都依赖自己的上下文。它们的特点是：")]),s._v(" "),t("ul",[t("li",[s._v("global：全局环境，JavaScript运行便会首先进入该环境，其中可能包括很多的function和eval的实例。")]),s._v(" "),t("li",[s._v("function：函数环境，函数的每次调用都会进入这个函数执行的上下文。")]),s._v(" "),t("li",[s._v("eval：运算执行环境，eval函数的每一次执行，也会进入eval执行中的上下文。")])]),s._v(" "),t("h4",{attrs:{id:"看一段代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#看一段代码"}},[s._v("#")]),s._v(" 看一段代码：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("function bar() {\n  console.log(2)\n}\nfunction foo() {\n  console.log(1);\n  bar();\n  console.log(3);\n}\nconsole.log(0);\nfoo();\nconsole.log(4);\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br")])]),t("h4",{attrs:{id:"满满全是打印的一个例子-最终会按照顺序输出0-4-我们来大体描述一下它的执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#满满全是打印的一个例子-最终会按照顺序输出0-4-我们来大体描述一下它的执行"}},[s._v("#")]),s._v(" 满满全是打印的一个例子，最终会按照顺序输出0-4，我们来大体描述一下它的执行：")]),s._v(" "),t("p",[s._v("1.首先代码进入了全局环境，记录了一些声明的变量；"),t("br"),s._v("\n2.执行console.log(0)，完成后，执行foo函数调用，进入一个函数环境foo；全局环境停止执行；"),t("br"),s._v("\n3.执行console.log(1)，执行完成后，执行bar函数调用，进入另一个函数环境bar；foo环境也停止执行；"),t("br"),s._v("\n4.执行console.log(2),执行完成后,返回到foo环境，执行执行console.log(3)；"),t("br"),s._v("\n5.全局环境继续执行，执行执行console.log(4)，完成后，代码全部执行完毕。")]),s._v(" "),t("h4",{attrs:{id:"这个流程很简单-console-log其实也是一个执行上下文就不细说了。这样细节的可以描述可以理清楚一点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#这个流程很简单-console-log其实也是一个执行上下文就不细说了。这样细节的可以描述可以理清楚一点"}},[s._v("#")]),s._v(" 这个流程很简单，console.log其实也是一个执行上下文就不细说了。这样细节的可以描述可以理清楚一点：")]),s._v(" "),t("h4",{attrs:{id:"代码执行会先进入一个全局环境-而其中会发生很多调用-进入一些函数环境-而函数环境又可能会调用其它函数甚至是递归-生成更多函数环境-以此可能产生无限多个上下文环境。而当某一个函数环境执行完成后就会返回继续执行之前调用它的环境。这种一层层的调用实现的方式就是-栈-了。表现就是在事件循环那一篇讲的-调用栈-。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码执行会先进入一个全局环境-而其中会发生很多调用-进入一些函数环境-而函数环境又可能会调用其它函数甚至是递归-生成更多函数环境-以此可能产生无限多个上下文环境。而当某一个函数环境执行完成后就会返回继续执行之前调用它的环境。这种一层层的调用实现的方式就是-栈-了。表现就是在事件循环那一篇讲的-调用栈-。"}},[s._v("#")]),s._v(" 代码执行会先进入一个全局环境，而其中会发生很多调用，进入一些函数环境，而函数环境又可能会调用其它函数甚至是递归，生成更多函数环境，以此可能产生无限多个上下文环境。而当某一个函数环境执行完成后就会返回继续执行之前调用它的环境。这种一层层的调用实现的方式就是“栈”了。表现就是在事件循环那一篇讲的“调用栈”。")]),s._v(" "),t("p",[t("img",{attrs:{src:a(527),alt:"EC-base-call"}})]),s._v(" "),t("h4",{attrs:{id:"那么说了半天-什么是执行上下文呢-上面所关注的点好像也都是代码的执行。其实-执行上下文就可以理解为执行对应栈所需要的信息。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#那么说了半天-什么是执行上下文呢-上面所关注的点好像也都是代码的执行。其实-执行上下文就可以理解为执行对应栈所需要的信息。"}},[s._v("#")]),s._v(" 那么说了半天，什么是执行上下文呢？上面所关注的点好像也都是代码的执行。其实，执行上下文就可以理解为"),t("strong",[s._v("执行对应栈所需要的信息。")])]),s._v(" "),t("h4",{attrs:{id:"我们把执行上下文先抽象的理解为一个object-也就是键值对集合-那么每一个执行上下文都会保存一些属性来追踪关联代码的执行进度。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我们把执行上下文先抽象的理解为一个object-也就是键值对集合-那么每一个执行上下文都会保存一些属性来追踪关联代码的执行进度。"}},[s._v("#")]),s._v(" 我们把执行上下文先抽象的理解为一个object，也就是键值对集合，那么每一个执行上下文都会保存一些属性来追踪关联代码的执行进度。")]),s._v(" "),t("h4",{attrs:{id:"按照es6的分类方式它包括三种主要信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#按照es6的分类方式它包括三种主要信息"}},[s._v("#")]),s._v(" 按照ES6的分类方式它包括三种主要信息：")]),s._v(" "),t("p",[s._v("1.Lexical Environment 词法环境"),t("br"),s._v("\n2.Variable Environment 变量环境"),t("br"),s._v("\n3.this value  this指针")]),s._v(" "),t("h4",{attrs:{id:"接下来详细讲一下。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接下来详细讲一下。"}},[s._v("#")]),s._v(" 接下来详细讲一下。")]),s._v(" "),t("h3",{attrs:{id:"lexical-environment"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lexical-environment"}},[s._v("#")]),s._v(" Lexical Environment")]),s._v(" "),t("h4",{attrs:{id:"词法环境-简单来讲-可以抽象的理解为一个对象-记录的是-标识符-和具体函数及变量的映射关系。它实际存储的是let-const-定义的函数声明和变量绑定。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#词法环境-简单来讲-可以抽象的理解为一个对象-记录的是-标识符-和具体函数及变量的映射关系。它实际存储的是let-const-定义的函数声明和变量绑定。"}},[s._v("#")]),s._v(" 词法环境，简单来讲，可以抽象的理解为一个对象，记录的是“标识符”和具体函数及变量的映射关系。它实际存储的是let，const 定义的函数声明和变量绑定。")]),s._v(" "),t("h4",{attrs:{id:"一个词法环境一般由两个部分组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一个词法环境一般由两个部分组成"}},[s._v("#")]),s._v(" 一个词法环境一般由两个部分组成：")]),s._v(" "),t("ol",[t("li",[s._v("环境记录(enviroment record)，用来存储变量和函数声明的具体位置。而它又根据执行环境类型不同，而分为两种。")])]),s._v(" "),t("ul",[t("li",[s._v("函数执行环境及catch中记录器为"),t("strong",[s._v("声明式环境记录器")]),s._v("。存储变量、函数、和函数参数，声明式环境记录器包含一个传递给函数的argument对象。")]),s._v(" "),t("li",[s._v("全局执行环境及with的执行环境记录器为"),t("strong",[s._v("对象环境记录器")]),s._v("。"),t("br"),s._v("\n2.对外部词法环境的引用(outer)，通过它访问父级的词法环境，和作用域相关。")])]),s._v(" "),t("h4",{attrs:{id:"伪代码模拟全局和函数执行环境的词法环境结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#伪代码模拟全局和函数执行环境的词法环境结构"}},[s._v("#")]),s._v(" 伪代码模拟全局和函数执行环境的词法环境结构")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('GlobalExectionContext = {\n  LexicalEnvironment: {\n    EnviromentRecord: {\n      Type: "Object"\n      ... // 记录变量和函数声明\n    },\n    outer: <null>\n  }\n}\n\nFunctionExectionContext = {\n  LexicalEnvironment: {\n    EnviromentRecord: {\n      Type: "Declarative"\n      ... // 记录变量和函数声明以及arguments\n    },\n    outer: <Global or outer function environment reference>  // GlobalExectionContext 或者 函数外其它函数的词法环境\n  }\n}\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br")])]),t("h3",{attrs:{id:"variable-environment"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#variable-environment"}},[s._v("#")]),s._v(" Variable Environment")]),s._v(" "),t("h4",{attrs:{id:"变量环境-其实也是一种词法环境-一样有环境记录与外部环境引入。它是用来存储变量声明语句在执行上下文中创建的绑定关系。即存储var声明的变量的绑定。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量环境-其实也是一种词法环境-一样有环境记录与外部环境引入。它是用来存储变量声明语句在执行上下文中创建的绑定关系。即存储var声明的变量的绑定。"}},[s._v("#")]),s._v(" 变量环境，其实也是一种词法环境，一样有环境记录与外部环境引入。它是用来存储变量声明语句在执行上下文中创建的绑定关系。即存储var声明的变量的绑定。")]),s._v(" "),t("h4",{attrs:{id:"假设有如下代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#假设有如下代码"}},[s._v("#")]),s._v(" 假设有如下代码：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("const a = 1;\nlet b = 2;\nvar c;\n\nfunction multiply(d, e) {  \n var f = 4;\n return d * e * f;  \n}\n\nc = multiply(5, 6);\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("h4",{attrs:{id:"用伪代码表示这段代码的词法环境和变量环境的创建内容"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用伪代码表示这段代码的词法环境和变量环境的创建内容"}},[s._v("#")]),s._v(" 用伪代码表示这段代码的词法环境和变量环境的创建内容：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('// 全局上下文\nGlobalExectionContext = {\n  LexicalEnvironment: {\n    EnviromentRecord: {\n      Type: "Object",\n      a: <uninitialized>, \n      b: <uninitialized>, \n      multiply: <func>\n    },\n    outer: <null>\n  },\n  VariableEnvironment: {\n    EnviromentRecord: {\n      Type: "Object",\n      c: undefined\n    },\n    outer: <null>\n  }\n}\n// 调用multiply(5, 6) 函数上下文创建\nFunctionExectionContext = {\n  LexicalEnvironment: {\n    EnviromentRecord: {\n      Type: "Declarative"\n      Arguments: {0: 5, 1: 6, length: 2}\n    },\n    outer: <GlobalExectionContext>\n  },\n  VariableEnvironment: {\n    EnviromentRecord: {\n      Type: "Declarative"\n      f: undefined\n    },\n    outer: <GlobalExectionContext>\n  }\n}\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br"),t("span",{staticClass:"line-number"},[s._v("21")]),t("br"),t("span",{staticClass:"line-number"},[s._v("22")]),t("br"),t("span",{staticClass:"line-number"},[s._v("23")]),t("br"),t("span",{staticClass:"line-number"},[s._v("24")]),t("br"),t("span",{staticClass:"line-number"},[s._v("25")]),t("br"),t("span",{staticClass:"line-number"},[s._v("26")]),t("br"),t("span",{staticClass:"line-number"},[s._v("27")]),t("br"),t("span",{staticClass:"line-number"},[s._v("28")]),t("br"),t("span",{staticClass:"line-number"},[s._v("29")]),t("br"),t("span",{staticClass:"line-number"},[s._v("30")]),t("br"),t("span",{staticClass:"line-number"},[s._v("31")]),t("br"),t("span",{staticClass:"line-number"},[s._v("32")]),t("br"),t("span",{staticClass:"line-number"},[s._v("33")]),t("br"),t("span",{staticClass:"line-number"},[s._v("34")]),t("br"),t("span",{staticClass:"line-number"},[s._v("35")]),t("br"),t("span",{staticClass:"line-number"},[s._v("36")]),t("br")])]),t("h3",{attrs:{id:"this-value"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this-value"}},[s._v("#")]),s._v(" this value")]),s._v(" "),t("h4",{attrs:{id:"this指针-就是我们常说的this值-在这里先不讨论什么什么执行时this指向谁-刚才说了this是执行上下文的一个属性-它没有var-this-只是在上下文创建阶段就确定了this的值。当我们在代码中使用了this-这个this的值就直接从执行的上下文中获取-而不是通过词法环境去搜索。this的值只取决于进入上下文时的情况。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this指针-就是我们常说的this值-在这里先不讨论什么什么执行时this指向谁-刚才说了this是执行上下文的一个属性-它没有var-this-只是在上下文创建阶段就确定了this的值。当我们在代码中使用了this-这个this的值就直接从执行的上下文中获取-而不是通过词法环境去搜索。this的值只取决于进入上下文时的情况。"}},[s._v("#")]),s._v(" this指针，就是我们常说的this值，在这里先不讨论什么什么执行时this指向谁，刚才说了this是执行上下文的一个属性，它没有var this，只是在上下文创建阶段就确定了this的值。当我们在代码中使用了this，这个this的值就直接从执行的上下文中获取，而不是通过词法环境去搜索。this的值只取决于进入上下文时的情况。")]),s._v(" "),t("h4",{attrs:{id:"执行上下文的主要内容可以说是这些-上面主要是它的创建阶段-我们可以发现些小问题-在创建的时候-function和var是会被初始化的-function甚至会被赋值-这里面其实关系到了我们常说的变量提升。可以多做一下思考。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文的主要内容可以说是这些-上面主要是它的创建阶段-我们可以发现些小问题-在创建的时候-function和var是会被初始化的-function甚至会被赋值-这里面其实关系到了我们常说的变量提升。可以多做一下思考。"}},[s._v("#")]),s._v(" 执行上下文的主要内容可以说是这些，上面主要是它的创建阶段，我们可以发现些小问题，在创建的时候，function和var是会被初始化的，function甚至会被赋值，这里面其实关系到了我们常说的变量提升。可以多做一下思考。")]),s._v(" "),t("h4",{attrs:{id:"那么讲了创建阶段具体有什么用呢-接下来需要再看一下它的执行阶段。通过执行阶段-了解作用域链。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#那么讲了创建阶段具体有什么用呢-接下来需要再看一下它的执行阶段。通过执行阶段-了解作用域链。"}},[s._v("#")]),s._v(" 那么讲了创建阶段具体有什么用呢？接下来需要再看一下它的执行阶段。通过执行阶段，了解作用域链。")]),s._v(" "),t("h2",{attrs:{id:"作用域链-scope-chains"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域链-scope-chains"}},[s._v("#")]),s._v(" 作用域链(Scope Chains)")]),s._v(" "),t("h4",{attrs:{id:"通过上面的执行上下文的创建-我们可以构思出一段代码在其创建时以及进入函数上下文的结构-通过这个结构-我们先知道一个概念叫做-作用域-。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过上面的执行上下文的创建-我们可以构思出一段代码在其创建时以及进入函数上下文的结构-通过这个结构-我们先知道一个概念叫做-作用域-。"}},[s._v("#")]),s._v(" 通过上面的执行上下文的创建，我们可以构思出一段代码在其创建时以及进入函数上下文的结构，通过这个结构，我们先知道一个概念叫做“作用域”。")]),s._v(" "),t("h4",{attrs:{id:"在创建执行上下文的时候-把每一个变量-函数声明都保存在了-环境记录-enviroment-record-当中-而在执行的时候当使用到了某一个-标识符-那么就会建立这个查找-通过enviroment-record中的内容-找到对应的引用。而每一个enviroment-record中保存的绑定关系就是其作用域。我们可以通过它确定一个变量所在的周期以及区域。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在创建执行上下文的时候-把每一个变量-函数声明都保存在了-环境记录-enviroment-record-当中-而在执行的时候当使用到了某一个-标识符-那么就会建立这个查找-通过enviroment-record中的内容-找到对应的引用。而每一个enviroment-record中保存的绑定关系就是其作用域。我们可以通过它确定一个变量所在的周期以及区域。"}},[s._v("#")]),s._v(" 在创建执行上下文的时候，把每一个变量/函数声明都保存在了**环境记录(Enviroment Record)当中，而在执行的时候当使用到了某一个“标识符”，那么就会建立这个查找，通过Enviroment Record中的内容，找到对应的引用。而每一个Enviroment Record中保存的绑定关系就是其作用域。我们可以通过它确定一个变量所在的周期以及区域。")]),s._v(" "),t("h4",{attrs:{id:"作用域链-就是链式的查找方式了-除了enviroment-record-我们还有一个关键要素outer-绑定的是它的外层上下文。分析一下如下代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域链-就是链式的查找方式了-除了enviroment-record-我们还有一个关键要素outer-绑定的是它的外层上下文。分析一下如下代码"}},[s._v("#")]),s._v(" 作用域链，就是链式的查找方式了，除了Enviroment Record，我们还有一个关键要素outer，绑定的是它的外层上下文。分析一下如下代码：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var x = 10;\n\nfunction a() {\n  console.log(x);\n}\n\nfunction b () {\n  var x = 5;\n  a();\n}\n\nb();\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br")])]),t("h4",{attrs:{id:"首先-js引擎创建一个全局上下文-其内部大概长这样"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#首先-js引擎创建一个全局上下文-其内部大概长这样"}},[s._v("#")]),s._v(" 首先，JS引擎创建一个全局上下文，其内部大概长这样：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('GlobalExectionContext = {\n  LexicalEnvironment: {\n    EnviromentRecord: {\n      Type: "Object",\n      a: <func>, \n      b: <func>\n    },\n    outer: <null>\n  },\n  VariableEnvironment: {\n    EnviromentRecord: {\n      Type: "Object",\n      x: undefined\n    },\n    outer: <GlobalExectionContext>\n  }\n}\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br")])]),t("h4",{attrs:{id:"执行代码-更改variableenvironment中的环境记录-把x设置为10。接着执行b-按照作用域查找到当前上下文enviroment-record中有b-执行-建立一个函数b的上下文-由于其函数b的声明所在上下文为globalexectioncontext-所以将其设置为函数上下文的outer。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行代码-更改variableenvironment中的环境记录-把x设置为10。接着执行b-按照作用域查找到当前上下文enviroment-record中有b-执行-建立一个函数b的上下文-由于其函数b的声明所在上下文为globalexectioncontext-所以将其设置为函数上下文的outer。"}},[s._v("#")]),s._v(" 执行代码，更改VariableEnvironment中的环境记录，把x设置为10。接着执行b()，按照作用域查找到当前上下文Enviroment Record中有b，执行，建立一个函数b的上下文，由于其函数b的声明所在上下文为GlobalExectionContext，所以将其设置为函数上下文的outer。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('// 全局上下文\nGlobalExectionContext = {...}\n// b()上下文\nFunctionExectionContext = {\n  LexicalEnvironment: {\n    ...\n    outer: <GlobalExectionContext>\n  },\n  VariableEnvironment: {\n    EnviromentRecord: {\n      Type: "Declarative",\n      x: undefined\n    },\n    outer: <GlobalExectionContext>\n  }\n}\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br")])]),t("h4",{attrs:{id:"重点来了-接着执行函数b中的内容-x-5-在变量环境中x设置为5-执行a-在当前environment-record下未找到a-通过outer-向外查找。查找globalexectioncontext即全局上下文-发现函数a-开始执行-建立函数a的上下文-由于其函数a的声明所在上下文为globalexectioncontext-所以将其设置为函数上下文的outer。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重点来了-接着执行函数b中的内容-x-5-在变量环境中x设置为5-执行a-在当前environment-record下未找到a-通过outer-向外查找。查找globalexectioncontext即全局上下文-发现函数a-开始执行-建立函数a的上下文-由于其函数a的声明所在上下文为globalexectioncontext-所以将其设置为函数上下文的outer。"}},[s._v("#")]),s._v(" 重点来了，接着执行函数b中的内容，x = 5，在变量环境中x设置为5，执行a()，在当前Environment Record下未找到a，通过outer，向外查找。查找GlobalExectionContext即全局上下文，发现函数a，开始执行，建立函数a的上下文，由于其函数a的声明所在上下文为GlobalExectionContext，所以将其设置为函数上下文的outer。")]),s._v(" "),t("div",{staticClass:"language-// 全局上下文 line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("GlobalExectionContext = {...}\n// b()上下文\nFunctionExectionContext = {...}\n// a()上下文\nFunctionExectionContext = {\n  LexicalEnvironment: {\n    ...\n    outer: <GlobalExectionContext>\n  },\n  VariableEnvironment: {\n    ...\n    outer: <GlobalExectionContext>\n  }\n}\n\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br")])]),t("h4",{attrs:{id:"接着执行函数a-执行console-log-x-在当前environment-record下未找到x-根据outer外向查找-在全局环境下查找到x-且值为10-将其输出。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接着执行函数a-执行console-log-x-在当前environment-record下未找到x-根据outer外向查找-在全局环境下查找到x-且值为10-将其输出。"}},[s._v("#")]),s._v(" 接着执行函数a，执行console.log(x)，在当前Environment Record下未找到x，根据outer外向查找，在全局环境下查找到x，且值为10，将其输出。")]),s._v(" "),t("h4",{attrs:{id:"看了上面的代码上下文的创建执行过程-作用域其实就是在查找变量时-如果当前上下文中没有该变量-则根据outer向外查找-直到outer为null。因此-我们可以明白-为什么在不同的函数中声明的变量不一定能够访问得到-并且也清楚了变量的查找方式适合原型链相似的查找流程。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#看了上面的代码上下文的创建执行过程-作用域其实就是在查找变量时-如果当前上下文中没有该变量-则根据outer向外查找-直到outer为null。因此-我们可以明白-为什么在不同的函数中声明的变量不一定能够访问得到-并且也清楚了变量的查找方式适合原型链相似的查找流程。"}},[s._v("#")]),s._v(" 看了上面的代码上下文的创建执行过程，作用域其实就是在查找变量时，如果当前上下文中没有该变量，则根据outer向外查找，直到outer为null。因此，我们可以明白，为什么在不同的函数中声明的变量不一定能够访问得到，并且也清楚了变量的查找方式适合原型链相似的查找流程。")]),s._v(" "),t("h2",{attrs:{id:"闭包-closures"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包-closures"}},[s._v("#")]),s._v(" 闭包(Closures)")]),s._v(" "),t("h4",{attrs:{id:"变量查找得问题也是在函数执行中的一个主要问题-我们现在直到了它是又一个作用域链的存在去查找的。我们也清楚了-各个作用域之间的变量封闭性。那么我们如果想要访问一个函数中的变量该怎么办-我们可以通过在函数的内部-在定义一个函数。比如"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量查找得问题也是在函数执行中的一个主要问题-我们现在直到了它是又一个作用域链的存在去查找的。我们也清楚了-各个作用域之间的变量封闭性。那么我们如果想要访问一个函数中的变量该怎么办-我们可以通过在函数的内部-在定义一个函数。比如"}},[s._v("#")]),s._v(" 变量查找得问题也是在函数执行中的一个主要问题，我们现在直到了它是又一个作用域链的存在去查找的。我们也清楚了，各个作用域之间的变量封闭性。那么我们如果想要访问一个函数中的变量该怎么办？我们可以通过在函数的内部，在定义一个函数。比如：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var num = 99;\nfunction fn1() {\n  var num = 0;\n  return function fn2() {\n    console.log(++num);\n  }\n}\nvar addNumFn = fn1();\naddNumFn(); // 1\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br")])]),t("h4",{attrs:{id:"可以看到-我们最终执行了fn1返回的函数-可以获取到fn1中num变量-可是我们之前讲到了-函数在返回之后-会把栈推出-那么对应的上下文也会被销毁的-返回的fn2-是如何访问到已经被销毁的fn1上下文的呢-原因是-函数在创建的时候-会保存一个私有属性-scope-其中存储的就是父级上下文的作用域链-这其中也就是会保存对应的环境记录啦-所以最终哪怕fn1被销毁也是可以访问到的。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可以看到-我们最终执行了fn1返回的函数-可以获取到fn1中num变量-可是我们之前讲到了-函数在返回之后-会把栈推出-那么对应的上下文也会被销毁的-返回的fn2-是如何访问到已经被销毁的fn1上下文的呢-原因是-函数在创建的时候-会保存一个私有属性-scope-其中存储的就是父级上下文的作用域链-这其中也就是会保存对应的环境记录啦-所以最终哪怕fn1被销毁也是可以访问到的。"}},[s._v("#")]),s._v(" 可以看到，我们最终执行了fn1返回的函数，可以获取到fn1中num变量，可是我们之前讲到了，函数在返回之后，会把栈推出，那么对应的上下文也会被销毁的，返回的fn2，是如何访问到已经被销毁的fn1上下文的呢？原因是，函数在创建的时候，会保存一个私有属性[[scope]]，其中存储的就是父级上下文的作用域链，这其中也就是会保存对应的环境记录啦，所以最终哪怕fn1被销毁也是可以访问到的。")]),s._v(" "),t("h4",{attrs:{id:"并且还需要说明的是-在一个上下文中-声明的函数保存的-scope-是同一份-比如修改下上面的代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并且还需要说明的是-在一个上下文中-声明的函数保存的-scope-是同一份-比如修改下上面的代码"}},[s._v("#")]),s._v(" 并且还需要说明的是，在一个上下文中，声明的函数保存的[[scope]]是同一份，比如修改下上面的代码：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var num = 99;\nfunction fn1() {\n  var num = 0;\n  return {\n    fn2() {\n      console.log(++num);\n    },\n    fn3() {\n      console.log(--num);\n    }\n  }\n}\nvar changeNumFn = fn1();\nchangeNumFn.fn2(); // 1\nchangeNumFn.fn3(); // 0\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br")])]),t("h4",{attrs:{id:"可以看出在执行fn3的时候-num是被fn2进行计算过的。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可以看出在执行fn3的时候-num是被fn2进行计算过的。"}},[s._v("#")]),s._v(" 可以看出在执行fn3的时候，num是被fn2进行计算过的。")]),s._v(" "),t("h4",{attrs:{id:"那闭包是什么-闭包其实就是携带了-scope-也就是写到了执行环境的函数。实际上函数创建时-都有这个属性-也就是说每一个函数都是闭包。-下面举一个常见的案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#那闭包是什么-闭包其实就是携带了-scope-也就是写到了执行环境的函数。实际上函数创建时-都有这个属性-也就是说每一个函数都是闭包。-下面举一个常见的案例"}},[s._v("#")]),s._v(" 那闭包是什么，闭包其实就是携带了[[scope]]也就是写到了执行环境的函数。实际上函数创建时，都有这个属性，也就是说每一个函数都是闭包。  下面举一个常见的案例：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("for(var i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i);\n  }, i * 1000);\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h4",{attrs:{id:"这个案例-乍一看-会每过一秒输出一次i-分别输出0-1-2-3-4。实际上会输出5次5-为什么呢-联系我们之前说过的事件循环-settimeout最终回放到任务队列中等待执行。而属于主线的任务for循环可不会停-最终创造了五个定时器-而i也会在执行最后一次i-后为5-当在执行回调的时候-在当前匿名函数上下文中是没有i的-全局中的i已然是5-所以就是这么个结果。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#这个案例-乍一看-会每过一秒输出一次i-分别输出0-1-2-3-4。实际上会输出5次5-为什么呢-联系我们之前说过的事件循环-settimeout最终回放到任务队列中等待执行。而属于主线的任务for循环可不会停-最终创造了五个定时器-而i也会在执行最后一次i-后为5-当在执行回调的时候-在当前匿名函数上下文中是没有i的-全局中的i已然是5-所以就是这么个结果。"}},[s._v("#")]),s._v(" 这个案例，乍一看，会每过一秒输出一次i，分别输出0，1，2，3，4。实际上会输出5次5.为什么呢？联系我们之前说过的事件循环，setTimeout最终回放到任务队列中等待执行。而属于主线的任务for循环可不会停，最终创造了五个定时器，而i也会在执行最后一次i++后为5，当在执行回调的时候，在当前匿名函数上下文中是没有i的，全局中的i已然是5，所以就是这么个结果。")]),s._v(" "),t("h4",{attrs:{id:"那么-我们用闭包来实现我们最初的目的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#那么-我们用闭包来实现我们最初的目的"}},[s._v("#")]),s._v(" 那么，我们用闭包来实现我们最初的目的：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("for(var i = 0; i < 5; i++) {\n  (function(i) {\n    setTimeout(() => {\n      console.log(i);\n    }, i * 1000)\n  })(i);\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("h4",{attrs:{id:"这里我们在settimeout外层套了一层函数子调用-并且传递了每次循环的i值-创建了一个函数上下文-而settimeout同步的部分会获取到自调用函数中的i-异步部分在进入任务队列后-主线执行完毕-自调用函数也出栈后-每个异步回调都通过自己的作用域链保存的变量获取到之前的i值输出。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#这里我们在settimeout外层套了一层函数子调用-并且传递了每次循环的i值-创建了一个函数上下文-而settimeout同步的部分会获取到自调用函数中的i-异步部分在进入任务队列后-主线执行完毕-自调用函数也出栈后-每个异步回调都通过自己的作用域链保存的变量获取到之前的i值输出。"}},[s._v("#")]),s._v(" 这里我们在setTimeout外层套了一层函数子调用，并且传递了每次循环的i值，创建了一个函数上下文，而setTimeout同步的部分会获取到自调用函数中的i，异步部分在进入任务队列后，主线执行完毕，自调用函数也出栈后，每个异步回调都通过自己的作用域链保存的变量获取到之前的i值输出。")]),s._v(" "),t("h2",{attrs:{id:"this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[s._v("#")]),s._v(" this")]),s._v(" "),t("h4",{attrs:{id:"this在javascript中是一个关键字-执行的是当前代码块的运行环境-为什么需要这么一个东西呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this在javascript中是一个关键字-执行的是当前代码块的运行环境-为什么需要这么一个东西呢"}},[s._v("#")]),s._v(" this在JavaScript中是一个关键字，执行的是当前代码块的运行环境，为什么需要这么一个东西呢？")]),s._v(" "),t("h4",{attrs:{id:"我们知道javascript是没有类的概念的-也就是es6才出现了class-我们有的是对象和函数-函数可以作为对象的一个方法来进行调用-也可以直接调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我们知道javascript是没有类的概念的-也就是es6才出现了class-我们有的是对象和函数-函数可以作为对象的一个方法来进行调用-也可以直接调用"}},[s._v("#")]),s._v(" 我们知道JavaScript是没有类的概念的，也就是ES6才出现了class，我们有的是对象和函数，函数可以作为对象的一个方法来进行调用，也可以直接调用：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var num = 1;\nfunction fn() { console.log(num); }\nvar o = {\n  num: 2,\n  fn\n}\nfn();\no.fn();\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("h4",{attrs:{id:"而我们知道函数声明时就保存了父级的作用域链-而当我们想向java一样有类的概念-以方法访问到对象上的属性时-我们该如何做-通过传参吗-这样写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#而我们知道函数声明时就保存了父级的作用域链-而当我们想向java一样有类的概念-以方法访问到对象上的属性时-我们该如何做-通过传参吗-这样写"}},[s._v("#")]),s._v(" 而我们知道函数声明时就保存了父级的作用域链，而当我们想向Java一样有类的概念，以方法访问到对象上的属性时，我们该如何做，通过传参吗？这样写：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var num = 1;\nfunction fn(who) { console.log(who.num); }\nvar o = {\n  num: 2,\n  fn\n}\nfn(window);\no.fn(o);\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("h4",{attrs:{id:"没错-结果是想要的-但并不是类的效果-因此我们需要一个连接对象和函数之间桥梁-或者说在函数中访问到调用者信息的方式-出现了this。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#没错-结果是想要的-但并不是类的效果-因此我们需要一个连接对象和函数之间桥梁-或者说在函数中访问到调用者信息的方式-出现了this。"}},[s._v("#")]),s._v(" 没错，结果是想要的，但并不是类的效果，因此我们需要一个连接对象和函数之间桥梁，或者说在函数中访问到调用者信息的方式，出现了this。")]),s._v(" "),t("h4",{attrs:{id:"在前面简单讲了this是执行上下文的一个属性-它是在执行上下文创建也就是函数调用的时候就被确定的-所以也是不可修改的。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在前面简单讲了this是执行上下文的一个属性-它是在执行上下文创建也就是函数调用的时候就被确定的-所以也是不可修改的。"}},[s._v("#")]),s._v(" 在前面简单讲了this是执行上下文的一个属性，它是在执行上下文创建也就是函数调用的时候就被确定的，所以也是不可修改的。")]),s._v(" "),t("h4",{attrs:{id:"在这里主要还是按照全局执行上下文和函数执行上下文两种类型来讲述。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在这里主要还是按照全局执行上下文和函数执行上下文两种类型来讲述。"}},[s._v("#")]),s._v(" 在这里主要还是按照全局执行上下文和函数执行上下文两种类型来讲述。")]),s._v(" "),t("h3",{attrs:{id:"全局中的this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局中的this"}},[s._v("#")]),s._v(" 全局中的this")]),s._v(" "),t("h4",{attrs:{id:"游览器全局中的this指向的就是全局对象window。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#游览器全局中的this指向的就是全局对象window。"}},[s._v("#")]),s._v(" 游览器全局中的this指向的就是全局对象window。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("// 通过声明绑定到window上\nvar num0 = 0;\n// 没有声明的赋值操作，隐式绑定到全局对象\nnum1 = 1;\n// 通过this绑定到全局对象\nthis.num2 = 2;\n\nconsole.log(window.num0); // 0\nconsole.log(this.num1); // 1\nconsole.log(num2); // 2\nconsole.log(this); // window\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br")])]),t("h4",{attrs:{id:"全局对象就是这么一个特点-没有什么复杂的地方-重点还是函数环境中的this。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局对象就是这么一个特点-没有什么复杂的地方-重点还是函数环境中的this。"}},[s._v("#")]),s._v(" 全局对象就是这么一个特点，没有什么复杂的地方，重点还是函数环境中的this。")]),s._v(" "),t("h3",{attrs:{id:"函数中的this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数中的this"}},[s._v("#")]),s._v(" 函数中的this")]),s._v(" "),t("h4",{attrs:{id:"函数中的this-我们有一句话-谁调用就指向谁-简单暴力-但是因为现在随着语言的复杂度提高-增加了一些场景-不能说这句话不对-只是没有办法把每一个场景给覆盖了。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数中的this-我们有一句话-谁调用就指向谁-简单暴力-但是因为现在随着语言的复杂度提高-增加了一些场景-不能说这句话不对-只是没有办法把每一个场景给覆盖了。"}},[s._v("#")]),s._v(" 函数中的this，我们有一句话，谁调用就指向谁，简单暴力，但是因为现在随着语言的复杂度提高，增加了一些场景，不能说这句话不对，只是没有办法把每一个场景给覆盖了。")]),s._v(" "),t("h3",{attrs:{id:"普通函数中的this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#普通函数中的this"}},[s._v("#")]),s._v(" 普通函数中的this")]),s._v(" "),t("h4",{attrs:{id:"我们先来看一下在普通函数下的场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我们先来看一下在普通函数下的场景"}},[s._v("#")]),s._v(" 我们先来看一下在普通函数下的场景：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var num = 1;\nfunction fn() { console.log(this.num); }\nfunction strictFn() {\n  'use strict';\n  console.log(this.num);\n}\nvar o = {\n  num: 2,\n  fn,\n  strictFn\n}\nfn(); // 1\no.fn(); // 2\nstrictFn(); // TypeError: Cannot read property 'num' of undefined\no.strictFn(); // 2\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br")])]),t("h4",{attrs:{id:"通过这个例子中-当函数fn单独调用时-this是指向window的-作为方法调用指向了调用它的引用o-而同样的函数只是加入了严格模式-在单独调用时-指向了undefined-而作为方法调用时表现相同。总结一下"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过这个例子中-当函数fn单独调用时-this是指向window的-作为方法调用指向了调用它的引用o-而同样的函数只是加入了严格模式-在单独调用时-指向了undefined-而作为方法调用时表现相同。总结一下"}},[s._v("#")]),s._v(" 通过这个例子中，当函数fn单独调用时，this是指向window的，作为方法调用指向了调用它的引用o，而同样的函数只是加入了严格模式，在单独调用时，指向了undefined，而作为方法调用时表现相同。总结一下：")]),s._v(" "),t("blockquote",[t("p",[s._v("当函数作为对象方法调用时，则this指向了调用函数的引用，当处于单独调用时，指向了undefined，只是非严格模式下，自动把它指向了window。")])]),s._v(" "),t("h3",{attrs:{id:"箭头函数中的this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数中的this"}},[s._v("#")]),s._v(" 箭头函数中的this")]),s._v(" "),t("h4",{attrs:{id:"es6出现的箭头函数-表现的和普通函数不太一样"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6出现的箭头函数-表现的和普通函数不太一样"}},[s._v("#")]),s._v(" ES6出现的箭头函数，表现的和普通函数不太一样：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var num = 0;\nvar fn = () => {\n  console.log(this.num);\n}\nvar o = {\n  num: 1,\n  fn,\n  newScope() {\n    var fn1 = () => {\n      console.log(this.num);\n    }\n    fn();\n    fn1();\n    return fn1;\n  }\n}\nfn(); // 0\no.fn(); // 0\nvar res = o.newScope(); // 0 1\nres(); // 1\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br")])]),t("h4",{attrs:{id:"我们先说一下箭头函数的this规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我们先说一下箭头函数的this规则"}},[s._v("#")]),s._v(" 我们先说一下箭头函数的this规则：")]),s._v(" "),t("blockquote",[t("p",[s._v("箭头函数本身没有this，它的this，继承自其函数声明时的上下文。与严格模式无关。")])]),s._v(" "),t("h4",{attrs:{id:"那么我们来解释一下上面的代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#那么我们来解释一下上面的代码"}},[s._v("#")]),s._v(" 那么我们来解释一下上面的代码，")]),s._v(" "),t("p",[s._v("1.全局中有一个num为0和一个箭头函数fn以及对象o，执行fn是一个箭头函数，没有this，它的声明上下文式全局，那么指向this，因此，输出window.num也就是0；"),t("br"),s._v("\n2.执行o.fn实际上执行的仍是相同指向的fn函数，只是调用者不同，但是由于箭头函数，可不管那么多，仍然找到的是声明时的上下文this，输出0；"),t("br"),s._v("\n3.执行o.newScope()，它是一个普通函数的方法调用，首先创造一个函数上下文，其中的this指向调用者也就是o，newScope中声明了一个箭头函数fn1，接着调用函数fn，根据作用域变量查找最终找到了全局的fn箭头函数，还是打印0；"),t("br"),s._v("\n4.执行o.newSAcope中的fn1时，它是一个箭头函数，声明式在this为0的函数作用域中，因此，this也指向o，输出1。"),t("br"),s._v("\n5.执行完后返回函数fn1，赋值给res，继续调用res，this仍然是fn1函数地址声明时的上下文。")]),s._v(" "),t("h3",{attrs:{id:"构造函数中的this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数中的this"}},[s._v("#")]),s._v(" 构造函数中的this")]),s._v(" "),t("h4",{attrs:{id:"构造函数的this指向-这个问题-我们先要搞清楚什么是构造函数。其实就是通过new调用的就是构造函数。所以构造函数的this也可以说就是new去调用的this时的指向。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数的this指向-这个问题-我们先要搞清楚什么是构造函数。其实就是通过new调用的就是构造函数。所以构造函数的this也可以说就是new去调用的this时的指向。"}},[s._v("#")]),s._v(" 构造函数的this指向，这个问题，我们先要搞清楚什么是构造函数。其实就是通过new调用的就是构造函数。所以构造函数的this也可以说就是new去调用的this时的指向。")]),s._v(" "),t("h4",{attrs:{id:"前面讲过了new做的事情-这里再看一下"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前面讲过了new做的事情-这里再看一下"}},[s._v("#")]),s._v(" 前面讲过了new做的事情，这里再看一下:")]),s._v(" "),t("p",[s._v("1.new运算符接受一个构造函数和一组调用参数；"),t("br"),s._v("\n2.首先会在内存中开辟一块空间，创造一个空对象；"),t("br"),s._v("\n3.将对象的_proto_指向构造函数的原型；"),t("br"),s._v("\n4.将构造函数中的this指向该对象，并传入参数执行；"),t("br"),s._v("\n5.如果执行结果是对象类型，则返回该结果，否则返回上面获取的对象。")]),s._v(" "),t("h4",{attrs:{id:"也就是说"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#也就是说"}},[s._v("#")]),s._v(" 也就是说：")]),s._v(" "),t("blockquote",[t("p",[s._v("通过new调用的this指向了创造的实例。")])]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("function Person(name) {\n  this.name = name;\n  this.sayHi = function() {\n    console.log(`${this.name}: Hi~`);\n  }\n  this.sayHello = () => {\n    console.log(`${this.name}: Hello~`);\n  }\n}\nvar p = new Person('YQL');\nconsole.log(p.name); // YQL\np.sayHi(); // YQL: Hi~\np.sayHello(); // YQL: Hello~\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br")])]),t("h4",{attrs:{id:"例子中-可以看到函数person中的this都指向了创造的实例p-使其拥有了属性name、sayhi和sayhello-后面的p-sayhi-实际上是我们前面说的方法调用了-哪怕换成箭头函数结果也一样-因为声明环境的this指向了实例。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例子中-可以看到函数person中的this都指向了创造的实例p-使其拥有了属性name、sayhi和sayhello-后面的p-sayhi-实际上是我们前面说的方法调用了-哪怕换成箭头函数结果也一样-因为声明环境的this指向了实例。"}},[s._v("#")]),s._v(" 例子中，可以看到函数Person中的this都指向了创造的实例p，使其拥有了属性name、sayHi和sayHello，后面的p.sayHi()实际上是我们前面说的方法调用了，哪怕换成箭头函数结果也一样，因为声明环境的this指向了实例。")]),s._v(" "),t("h3",{attrs:{id:"操作this的内置函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作this的内置函数"}},[s._v("#")]),s._v(" 操作this的内置函数")]),s._v(" "),t("h4",{attrs:{id:"this的主要场景就是上面的-我们可以看到在函数中this有时候是会让人意想不到的-或者说在有些场景下我们想要显示指定this的值该怎么办"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this的主要场景就是上面的-我们可以看到在函数中this有时候是会让人意想不到的-或者说在有些场景下我们想要显示指定this的值该怎么办"}},[s._v("#")]),s._v(" this的主要场景就是上面的，我们可以看到在函数中this有时候是会让人意想不到的，或者说在有些场景下我们想要显示指定this的值该怎么办？")]),s._v(" "),t("h4",{attrs:{id:"funciont对象的原型上定义了call、apply及bind方法来做这件事情。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#funciont对象的原型上定义了call、apply及bind方法来做这件事情。"}},[s._v("#")]),s._v(" Funciont对象的原型上定义了call、apply及bind方法来做这件事情。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var num = 0;\nfunction fn(arg1, arg2) {\n  console.log(this.num);\n  console.log(arg1, arg2);\n}\nfn('a', 'b'); // 0, 'a', 'b'\nfn.call({num: 1}, 'x', 'y'); // 1，'x', 'y'\nfn.apply({num: 2}, ['z', 'j']); // 2, 'z', 'j'\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("h4",{attrs:{id:"call和apply都是把第一参数作为this的指向传入后执行-只是后续传参的方式不同。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#call和apply都是把第一参数作为this的指向传入后执行-只是后续传参的方式不同。"}},[s._v("#")]),s._v(" call和apply都是把第一参数作为this的指向传入后执行，只是后续传参的方式不同。")]),s._v(" "),t("h4",{attrs:{id:"而bind则是返回一个函数并不执行-同样把this绑定到第一个参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#而bind则是返回一个函数并不执行-同样把this绑定到第一个参数"}},[s._v("#")]),s._v(" 而bind则是返回一个函数并不执行，同样把this绑定到第一个参数：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("var num = 0;\nfn = (arg1, arg2) => {\n  console.log(this.num);\n  console.log(arg1, arg2);\n}\nfn.bind({num: 1}, 'x', 'y')(); // 1，'x', 'y'\n\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("h4",{attrs:{id:"需要注意的时这三个函数用于不接受this的函数类型如箭头、class不会报错、不能按期望修改this-但可以传参。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#需要注意的时这三个函数用于不接受this的函数类型如箭头、class不会报错、不能按期望修改this-但可以传参。"}},[s._v("#")]),s._v(" 需要注意的时这三个函数用于不接受this的函数类型如箭头、class不会报错、不能按期望修改this，但可以传参。")]),s._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),t("h4",{attrs:{id:"本篇从执行上下文的类别不同讲到了我们通常理解的作用域链、闭包及this、理解其中的具体规则-以及它们的关系-有了更清晰的知识体系。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本篇从执行上下文的类别不同讲到了我们通常理解的作用域链、闭包及this、理解其中的具体规则-以及它们的关系-有了更清晰的知识体系。"}},[s._v("#")]),s._v(" 本篇从执行上下文的类别不同讲到了我们通常理解的作用域链、闭包及this、理解其中的具体规则，以及它们的关系，有了更清晰的知识体系。")])])}),[],!1,null,null,null);n.default=e.exports}}]);