(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{591:function(a,t,e){"use strict";e.r(t);var r=e(3),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("h3",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),e("h4",{attrs:{id:"本篇文章是javascript重塑篇的第二篇-对象篇。本篇讲述了javascript是如何设计对象模型以及javascript对象的两类属性。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#本篇文章是javascript重塑篇的第二篇-对象篇。本篇讲述了javascript是如何设计对象模型以及javascript对象的两类属性。"}},[a._v("#")]),a._v(" 本篇文章是JavaScript重塑篇的第二篇-对象篇。本篇讲述了JavaScript是如何设计对象模型以及JavaScript对象的两类属性。")])]),e("h4",{attrs:{id:""}},[e("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")])]),a._v(" "),e("h4",{attrs:{id:"关于javascript到底是面向对象还是基于对象一直存在争议。实际上-基于对象和面向对象两个形容词都出现在了javascript标准的各个版本当中。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于javascript到底是面向对象还是基于对象一直存在争议。实际上-基于对象和面向对象两个形容词都出现在了javascript标准的各个版本当中。"}},[a._v("#")]),a._v(" 关于JavaScript到底是面向对象还是基于对象一直存在争议。实际上，"),e("strong",[a._v("基于对象和面向对象两个形容词都出现在了JavaScript标准的各个版本当中。")])]),a._v(" "),e("h4",{attrs:{id:"我们先来看看javascript对基于对象的定义-语言和宿主的基础设施由对象来提供-并且javascript程序即是一系列互相通讯的对象集合-。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我们先来看看javascript对基于对象的定义-语言和宿主的基础设施由对象来提供-并且javascript程序即是一系列互相通讯的对象集合-。"}},[a._v("#")]),a._v(" 我们先来看看JavaScript对基于对象的定义：“语言和宿主的基础设施由对象来提供，并且JavaScript程序即是一系列互相通讯的对象集合”。")]),a._v(" "),e("h4",{attrs:{id:"可以看出-它表达的是对象对于语言的重要性。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可以看出-它表达的是对象对于语言的重要性。"}},[a._v("#")]),a._v(" 可以看出，它表达的是对象对于语言的重要性。")]),a._v(" "),e("h4",{attrs:{id:"那我们就先来讲讲面向对象。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#那我们就先来讲讲面向对象。"}},[a._v("#")]),a._v(" 那我们就先来讲讲面向对象。")]),a._v(" "),e("h2",{attrs:{id:"什么是面向对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是面向对象"}},[a._v("#")]),a._v(" 什么是面向对象？")]),a._v(" "),e("h4",{attrs:{id:"对象object在英文中-是一切事物的总称。可以理解为-万物皆对象。对于中文的-对象-我们更多的是把它当作一个专业的名词来理解。它是顺着人类思维模式产生的一种抽象。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象object在英文中-是一切事物的总称。可以理解为-万物皆对象。对于中文的-对象-我们更多的是把它当作一个专业的名词来理解。它是顺着人类思维模式产生的一种抽象。"}},[a._v("#")]),a._v(" 对象"),e("code",[a._v("Object")]),a._v("在英文中，是一切事物的总称。可以理解为：万物皆对象。对于中文的“对象”，我们更多的是把它当作一个专业的名词来理解。它是顺着人类思维模式产生的一种抽象。")]),a._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("h4",{attrs:{id:"在生活中-一个手机是一个对象-它可以打电话-上网。一台车也是一个对象-它可以行驶-有重量-空间。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在生活中-一个手机是一个对象-它可以打电话-上网。一台车也是一个对象-它可以行驶-有重量-空间。"}},[a._v("#")]),a._v(" 在生活中,一个手机是一个对象,它可以打电话，上网。一台车也是一个对象，它可以行驶，有重量，空间。")])]),e("h4",{attrs:{id:"在《面向对象分析与设计》这本书中-grady-booch-替我们做了总结-他认为-从人类的认知角度来说-对象应该是下列事物之一"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在《面向对象分析与设计》这本书中-grady-booch-替我们做了总结-他认为-从人类的认知角度来说-对象应该是下列事物之一"}},[a._v("#")]),a._v(" 在《面向对象分析与设计》这本书中，Grady Booch 替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一：")]),a._v(" "),e("p",[a._v("1.一个可以接触或者可以看见的东西；"),e("br"),a._v("\n2.人的智力可以理解的东西；"),e("br"),a._v("\n3.可以指导思考或行动(进行想象或施加动作)的东西；")]),a._v(" "),e("h2",{attrs:{id:"javascript对象的特征"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript对象的特征"}},[a._v("#")]),a._v(" JavaScript对象的特征")]),a._v(" "),e("h4",{attrs:{id:"在我看来-不论我们使用什么样的编程语言-我们都先应该去理解对象的本质特征-参考-grandy-booch《面向对象分析与设计》-。总结来看-对象有如下几个特点。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在我看来-不论我们使用什么样的编程语言-我们都先应该去理解对象的本质特征-参考-grandy-booch《面向对象分析与设计》-。总结来看-对象有如下几个特点。"}},[a._v("#")]),a._v(" 在我看来，不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征（参考 Grandy Booch《面向对象分析与设计》）。总结来看，对象有如下几个特点。")]),a._v(" "),e("ul",[e("li",[a._v("对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。")]),a._v(" "),e("li",[a._v("对象有状态：对象具有状态，同一对象可能处于不同状态之下。")]),a._v(" "),e("li",[a._v("对象具有行为：即对象的状态，可能因为它的行为产生变迁。")])]),a._v(" "),e("h4",{attrs:{id:"我们首先来看-对象具有唯一标识性-这个特点-举个栗子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我们首先来看-对象具有唯一标识性-这个特点-举个栗子"}},[a._v("#")]),a._v(" 我们首先来看“对象具有唯一标识性”这个特点，举个栗子：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var o1 = { a:1 };\nvar o2 = { a:1 };\nconsole.log(o1 == 02); // false\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("h4",{attrs:{id:"可以看出-即使两个变量的对象是一样的-但是这两个对象并不相等。这是因为对象的唯一标识性都是用内存地址来体现的-对象具有唯一标识的内存地址-所以具有唯一的标识。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可以看出-即使两个变量的对象是一样的-但是这两个对象并不相等。这是因为对象的唯一标识性都是用内存地址来体现的-对象具有唯一标识的内存地址-所以具有唯一的标识。"}},[a._v("#")]),a._v(" 可以看出，即使两个变量的对象是一样的，但是这两个对象并不相等。这是因为对象的唯一标识性都是用内存地址来体现的，对象具有唯一标识的内存地址，所以具有唯一的标识。")]),a._v(" "),e("h4",{attrs:{id:"再来看看第二个特征-状态-和第三个特征-行为-。其实在不同的语言中-有着不同的术语来描述它们-比如c-中称他们为-成员变量-和-成员函数-java中则称他们为-属性-和-方法-。而在javascript中-则是把这两则同一抽象为-属性-。举个栗子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#再来看看第二个特征-状态-和第三个特征-行为-。其实在不同的语言中-有着不同的术语来描述它们-比如c-中称他们为-成员变量-和-成员函数-java中则称他们为-属性-和-方法-。而在javascript中-则是把这两则同一抽象为-属性-。举个栗子"}},[a._v("#")]),a._v(" 再来看看第二个特征“状态”和第三个特征“行为”。其实在不同的语言中，有着不同的术语来描述它们，比如C++中称他们为“成员变量”和“成员函数”，Java中则称他们为“属性”和“方法”。而在JavaScript中，则是把这两则同一抽象为“属性”。举个栗子：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var o = {\n  d: 'my',\n  f() {\n    console.log(this.d);\n  }\n};\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("h4",{attrs:{id:"在这个对象o中-d和f都是它的一个属性。-提到了属性-这里要讲一下对象它有两类属性。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在这个对象o中-d和f都是它的一个属性。-提到了属性-这里要讲一下对象它有两类属性。"}},[a._v("#")]),a._v(" 在这个对象o中，d和f都是它的一个属性。 提到了属性，这里要讲一下对象它有两类属性。")]),a._v(" "),e("h2",{attrs:{id:"对象的两类属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象的两类属性"}},[a._v("#")]),a._v(" 对象的两类属性")]),a._v(" "),e("h4",{attrs:{id:"对-javascript-来说-属性并非只是简单的名称和值-javascript-用一组特征-attribute-来描述属性-property-。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对-javascript-来说-属性并非只是简单的名称和值-javascript-用一组特征-attribute-来描述属性-property-。"}},[a._v("#")]),a._v(" 对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。")]),a._v(" "),e("h4",{attrs:{id:"第一类属性是数据属性。它有四个特征"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一类属性是数据属性。它有四个特征"}},[a._v("#")]),a._v(" 第一类属性是数据属性。它有四个特征：")]),a._v(" "),e("ul",[e("li",[a._v("value: 就是属性的值。")]),a._v(" "),e("li",[a._v("writable： 决定属性能否被赋值。")]),a._v(" "),e("li",[a._v("enumerable： 决定for in能否枚举该属性。")]),a._v(" "),e("li",[a._v("configurable： 决定该属性能否被删除或者改变特征值。")])]),a._v(" "),e("h4",{attrs:{id:"大多数情况下-我们只需要关心数据属性的值也就是value即可。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大多数情况下-我们只需要关心数据属性的值也就是value即可。"}},[a._v("#")]),a._v(" 大多数情况下，我们只需要关心数据属性的值也就是value即可。")]),a._v(" "),e("h4",{attrs:{id:"第二类属性是访问器-getter-setter-属性-他也有四个特征"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二类属性是访问器-getter-setter-属性-他也有四个特征"}},[a._v("#")]),a._v(" 第二类属性是访问器(getter/setter)属性，他也有四个特征：")]),a._v(" "),e("ul",[e("li",[a._v("getter：函数或undefined，在取属性值时被调用。")]),a._v(" "),e("li",[a._v("setter：函数或undefined，在设置属性值时被调用。")]),a._v(" "),e("li",[a._v("enumerable： 决定for in能否枚举该属性。")]),a._v(" "),e("li",[a._v("configurable： 决定该属性能否被删除或者改变特征值。")])]),a._v(" "),e("h4",{attrs:{id:"可以把访问器属性视为一种函数的语法糖-它允许使用者在写和读属性时-得到完全不同的值。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可以把访问器属性视为一种函数的语法糖-它允许使用者在写和读属性时-得到完全不同的值。"}},[a._v("#")]),a._v(" 可以把访问器属性视为一种函数的语法糖，它允许使用者在写和读属性时，得到完全不同的值。")]),a._v(" "),e("h4",{attrs:{id:"我们通常用于定义属性的代码会产生数据属性-其中的writable、enumerable、configurable都默认为true。我们可以使用内置函数object-getownpropertydescripter来查看-如以下代码所示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我们通常用于定义属性的代码会产生数据属性-其中的writable、enumerable、configurable都默认为true。我们可以使用内置函数object-getownpropertydescripter来查看-如以下代码所示"}},[a._v("#")]),a._v(" 我们通常用于定义属性的代码会产生数据属性，其中的writable、enumerable、configurable都默认为true。我们可以使用内置函数Object.getOwnPropertyDescripter来查看，如以下代码所示：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var o = { name: \'my\' };\no.role = \'teacher\';\n// name和role都是属性数据\nObject.getOwnPropertyDescriptor(o, "name") // {value: "my", writable: true, enumerable: true, configurable: true}\nObject.getOwnPropertyDescriptor(o, "role") // {value: "teacher", writable: true, enumerable: true, configurable: true}\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br")])]),e("h4",{attrs:{id:"我们在这里使用了两种语法来定义属性-定义属性后-我们用javascript的api来查看这个属性-我们可以发现-这样定义出来的属性都是数据属性-writeable、enumerable、configurable都是默认值为true。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我们在这里使用了两种语法来定义属性-定义属性后-我们用javascript的api来查看这个属性-我们可以发现-这样定义出来的属性都是数据属性-writeable、enumerable、configurable都是默认值为true。"}},[a._v("#")]),a._v(" 我们在这里使用了两种语法来定义属性，定义属性后，我们用JavaScript的API来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable都是默认值为true。")]),a._v(" "),e("h4",{attrs:{id:"如果我们想要改变属性的特征-或者定义访问器属性-我们可以使用object-defineproperty-示例如下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果我们想要改变属性的特征-或者定义访问器属性-我们可以使用object-defineproperty-示例如下"}},[a._v("#")]),a._v(" 如果我们想要改变属性的特征，或者定义访问器属性，我们可以使用Object.defineProperty,示例如下：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var o = { name: \'my\' };\nObject.defineProperty(o, "role", { value: \'tuhao\', writable: false, enumerable: false, configurable: true});\nObject.getOwnPropertyDescriptor(o, "name") // {value: "my", writable: true, enumerable: true, configurable: true}\nObject.getOwnPropertyDescriptor(o, "role") // {value: "tuhao", writable: false, enumerable: false, configurable: true}\no.role = \'teacher\';\nconsole.log(o.role); // tuhao\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("h4",{attrs:{id:"这里我们可以得出-object-defineproperty可以改变属性的writable和enumerable。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这里我们可以得出-object-defineproperty可以改变属性的writable和enumerable。"}},[a._v("#")]),a._v(" 这里我们可以得出：Object.defineProperty可以改变属性的writable和enumerable。")]),a._v(" "),e("h4",{attrs:{id:"在创建对象时-也可以使用get和set关键字来创建访问器属性-代码如下所示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在创建对象时-也可以使用get和set关键字来创建访问器属性-代码如下所示"}},[a._v("#")]),a._v(" 在创建对象时，也可以使用get和set关键字来创建访问器属性，代码如下所示：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" var o = { get a() {return 1}};\n console.log(o.a); // 1\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("h4",{attrs:{id:"访问器属性和数据属性不同-每次访问属性都会执行getter或者setter函数。这里我们的getter函数返回了1-所以o-a每次都得到1。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#访问器属性和数据属性不同-每次访问属性都会执行getter或者setter函数。这里我们的getter函数返回了1-所以o-a每次都得到1。"}},[a._v("#")]),a._v(" 访问器属性和数据属性不同，每次访问属性都会执行getter或者setter函数。这里我们的getter函数返回了1，所以o.a每次都得到1。")]),a._v(" "),e("h4",{attrs:{id:"这样我们可以理解为javas对象的运行时是一个-属性的集合-属性以字符串或者symbol为key-以数据属性特征值或者访问器属性特征值为value。通过这种key-value的形式-用key来找到对应的value。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这样我们可以理解为javas对象的运行时是一个-属性的集合-属性以字符串或者symbol为key-以数据属性特征值或者访问器属性特征值为value。通过这种key-value的形式-用key来找到对应的value。"}},[a._v("#")]),a._v(" 这样我们可以理解为JavaS对象的运行时是一个“属性的集合”，属性以字符串或者Symbol为key，以数据属性特征值或者访问器属性特征值为value。通过这种key:value的形式，用key来找到对应的value。")]),a._v(" "),e("h4",{attrs:{id:"比较之下-javascript的对象系统设计的虽然特别-但它提供了完全运行时的对象系统-这使得它可以模仿多数面向对象编程范式-所以它也是正统的面向对象语言。-javascript-语言标准也已经明确说明-javascript-是一门面向对象的语言-我想标准中能这样说-正是因为-javascript-的高度动态性的对象系统。所以-我们应该在理解其设计思想的基础上充分挖掘它的能力-而不是机械地模仿其它语言。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#比较之下-javascript的对象系统设计的虽然特别-但它提供了完全运行时的对象系统-这使得它可以模仿多数面向对象编程范式-所以它也是正统的面向对象语言。-javascript-语言标准也已经明确说明-javascript-是一门面向对象的语言-我想标准中能这样说-正是因为-javascript-的高度动态性的对象系统。所以-我们应该在理解其设计思想的基础上充分挖掘它的能力-而不是机械地模仿其它语言。"}},[a._v("#")]),a._v(" 比较之下，JavaScript的对象系统设计的虽然特别，但它提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式，所以它也是正统的面向对象语言。(JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。所以，我们应该在理解其设计思想的基础上充分挖掘它的能力，而不是机械地模仿其它语言。)")]),a._v(" "),e("h4",{attrs:{id:"在下一篇中我会介绍javascript中的两种面向对象编程的范式-基于类和基于原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在下一篇中我会介绍javascript中的两种面向对象编程的范式-基于类和基于原型"}},[a._v("#")]),a._v(" 在下一篇中我会介绍JavaScript中的两种面向对象编程的范式：基于类和基于原型")])])}),[],!1,null,null,null);t.default=s.exports}}]);